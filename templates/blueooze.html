highp float rand(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

const float animSpeed = 0.06;

float getWaveHeight(int waveIndex)
{
    return 1.0;
}

float getWaveLength(int waveIndex)
{
    const float minWavelength = 1.0;
    const float maxWavelength = 25.0;

    return minWavelength + ((maxWavelength-minWavelength) * rand(vec2(float(waveIndex), 42.0)));
}

float getSpeed(int waveIndex)
{
    const float minSpeed = 0.01;
    const float maxSpeed = 0.16;

    return (minSpeed + ((maxSpeed-minSpeed) * rand(vec2(float(waveIndex), 420.0))))*animSpeed;
}

float getAngle(int waveIndex)
{
    if(waveIndex == 0) // just makes it look a little nicer.
    {
        return 0.0;
    }

    return rand(vec2(float(waveIndex), 69.0)) * 3.14 * 2.0;
}

float getHeightAtPoint(int waveIndex,vec2 uv)
{
    float angle = getAngle(waveIndex);
    float speed = getSpeed(waveIndex);

    float xMag = cos(angle);
    float yMag = sin(angle);

    float height = cos(((xMag*uv.x)+(yMag*uv.y)+(iTime*speed))*getWaveLength(waveIndex)) + 1.0;

    return (height/2.0)*getWaveHeight(waveIndex);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Number of layers (cos waves on top of each other).
    const int numLayers = 9;

    // For calculating the normal, which adjust all lighting.
    const float heightMulti = 100.0;
    const float xyMulti = 60.0;

    // Lighting Params.
    const float specularPower = 2.0;
    const vec3 ambient = vec3(0.1, 0.1, 0.1);
    const vec3 light = vec3(0.1, 0.2, 0.5);
    const vec3 spec = vec3(1.0, 1.0, 1.0);


    vec2 uv = fragCoord/iResolution.xy;

    float height = 0.0;

    float distToSample = 0.01;
    vec4 surroundingHeight = vec4(0.0,0.0,0.0,0.0);

    for(int layer = 0; layer < numLayers; ++layer)
    {
        height += getHeightAtPoint(layer, uv);

        surroundingHeight.x += getHeightAtPoint(layer, uv + vec2(distToSample,0.0));
        surroundingHeight.y += getHeightAtPoint(layer, uv + vec2(-distToSample,0.0));
        surroundingHeight.z += getHeightAtPoint(layer, uv + vec2(0.0,distToSample));
        surroundingHeight.w += getHeightAtPoint(layer, uv + vec2(0.0,-distToSample));
    }

    surroundingHeight /= float(numLayers);

    float sampleDeltaPosInWorldSpace = xyMulti * distToSample;

    vec3 lightDir = normalize(vec3(0.2, 0.1, 0.6));
    vec3 cameraDir = normalize(vec3(-0.2, -0.1, 0.6));


    vec3 p0 = vec3(sampleDeltaPosInWorldSpace, 0.0, surroundingHeight.x * heightMulti);
    vec3 p1 = vec3(-sampleDeltaPosInWorldSpace, 0.0, surroundingHeight.y * heightMulti);
    vec3 p2 = vec3(0.0, sampleDeltaPosInWorldSpace, surroundingHeight.z * heightMulti);

    vec3 normal = normalize(cross(p2-p0, p1-p0));

    vec3 lightReflect = normalize(-reflect(lightDir, normal));



    float lightStrength = clamp(dot(lightDir, normal), 0.0, 1.0);
    float specStrength = pow(clamp(dot(lightReflect, cameraDir),0.0,1.0),specularPower);

    specStrength = clamp(specStrength, 0.0, 1.0);


    fragColor.rgb = ambient + (light*lightStrength) + (spec*specStrength);

    vec4 cols = fragColor;
    uv.x -= 0.5;
    uv.y -= 0.5;    

<html>
<body style="margin:0;">

    <div class="clockdiv" style="width:80%; margin:auto;">

        <canvas id="canvas" width="256" height="256" style="top:0;left:0;width:100%;height:100%; border-radius:50%;"></canvas>

        <canvas style="padding: 0; position: relative; top: -100%; left: 0; width: 100%; z-index: -1; border-radius: 50%;" id="canvas6"></canvas>

    </div>
    <script>
        class renderclocksample6 {
            constructor() { this.canvas = document.getElementById("canvas"); this.backgroundColour = 'rgba(0,0,0,0)'; this.clockColour = '#FDFFFC'; this.handsColour = '#000000'; this.numbersType = 'none'; this.secondHandType = 'none'; this.handsEndType = 'rounded'; this.handsWidthType = 'tapered'; this.handsCentreType = 'circle'; this.handsLengthType = 'extended'; this.backgroundType = 'therefresh'; this.borderType = 'nothing'; this.dimensionType = '3d'; this.hourHandType = 'standard'; this.fps = 60; this.renderframe(); setInterval(this.renderframe.bind(this), 1000) }
            drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour; this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.ctx.restore(); this.drawFace(); this.drawNumbers() }
            renderframe() {
                this.body = document.querySelector("body"); var oldss = this.ss; this.ss = (this.body.clientWidth < this.body.clientHeight ? this.body.clientWidth : this.body.clientHeight) * 0.8; if (this.ss != oldss) { this.canvas.width = this.ss; this.canvas.height = this.ss; this.ctx = this.canvas.getContext("2d"); this.radius = this.canvas.height / 2; this.ctx.translate(this.radius, this.radius); this.canvasc = document.querySelector(".clockdiv"); this.canvasc.style.width = this.ss; this.canvasc.style.height = this.ss }
                this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(); this.drawTime()
            }
            formatNumber(n) { return n.toString().padStart(2, "0") }
            drawFace() {
                var grad; if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI); this.ctx.fillStyle = this.clockColour; this.ctx.fill() }
                if (this.borderType != "nothing") {
                    if (this.borderType == "gradient") { grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1); grad.addColorStop(0, this.clockColour); grad.addColorStop(0.5, this.handsColour); grad.addColorStop(1, this.clockColour); this.ctx.strokeStyle = grad } else { this.ctx.strokeStyle = this.handsColour }
                    this.ctx.lineWidth = this.radius * 0.03; this.ctx.stroke()
                }
            }
            drawNumbers() {
                if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -2; this.ctx.shadowOffsetY = 1 }
                var ang; var num; this.ctx.font = this.radius * 0.15 + "px arial"; this.ctx.textBaseline = "middle"; this.ctx.textAlign = "center"; this.ctx.fillStyle = "#CCCCCC"; switch (this.numbersType) {
                    case "roman": this.ctx.font = this.radius * 0.25 + "px times new roman"; for (num = 1; num < 13; num++) {
                        ang = num * Math.PI / 6; this.ctx.rotate(ang); this.ctx.translate(0, -this.radius * 0.85); var text = ""; var width = 0.11; switch (num) {
                            case 1:
                                text = " I ";
                                break;
                            case 2:
                                text = "II ";
                                break;
                            case 3:
                                text = "III";
                                break;
                            case 4:
                                text = "IV";
                                break;
                            case 5:
                                text = " V ";
                                break;
                            case 6:
                                text = "VI";
                                break;
                            case 7:
                                text = "VII";
                                break;
                            case 8:
                                text = "VIII";
                                width = 0.15;
                                break;
                            case 9:
                                text = "IX ";
                                break;
                            case 10:
                                text = " X ";
                                break;
                            case 11:
                                text = "XI ";
                                break;
                            case 12:
                                text = "XII";
                                break;
                            default:
                                break;
                        }
                        this.ctx.fillText(text, 0, 0, this.radius * width); this.ctx.rotate(-ang); this.ctx.rotate(ang); this.ctx.translate(0, this.radius * 0.85); this.ctx.rotate(-ang)
                    }
                        break; case "nothing": break
                }
            }
            drawTime() {
                var now = new Date(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); hour = hour % 12; hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60)); var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90; this.ctx.save(); if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -4; this.ctx.shadowOffsetY = 3 }
                if (this.handsCentreType == "circle" || this.handsCentreType == "circle") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI); this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour); this.ctx.fill() }
                var extension = 0; if (this.handsLengthType == "extended" || this.handsLengthType == "extended") { extension = this.radius * 0.1 }
                var lengthratio = 1; if (this.handsLengthType == "short") { lengthratio = 0.7 }
                if (this.hourHandType != "cutout") { this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension) }
                minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)); this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension); second = (second * Math.PI / 30); switch (this.secondHandType) { case 'nothing': break; case 'handscolour': this.drawHand(this.ctx, second, this.radius * 0.8, this.radius * 0.01, 0, '#DDDDDD', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#DDDDDD'; this.ctx.fill(); break; case 'red': this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#C71013'; this.ctx.fill(); break; default: break }
            }
            drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                if (colour == null) { colour = this.handsColour }
                if (transparentratio > 0) { this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius); this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, colour); this.strokestyle.addColorStop(1, colour); this.ctx.strokeStyle = this.strokestyle; this.ctx.lineCap = "butt" } else {
                    this.ctx.strokeStyle = colour; if (this.handsEndType == 'rounded') { this.ctx.lineCap = "round" }
                    switch (this.handsWidthType) { case "thin": width = width * 0.5; break; case "medium": break; case "thick": width = width * 2; break; default: break }
                }
                this.ctx.beginPath(); this.ctx.lineWidth = width; this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, -length); this.ctx.stroke(); this.ctx.rotate(-pos); if (neglength > 0) { this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, neglength); this.ctx.stroke(); this.ctx.rotate(-pos) }
            }
        }
        new renderclocksample6()
    </script>

    <script>
        "use strict";

        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }

            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgramFromSources(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        function main() {
            const canvas = document.querySelector("#canvas6");
            const gl = canvas.getContext("webgl");
            if (!gl) {
                return;
            }

            gl.canvas.style.Width = gl.canvas.clientWidth;
            gl.canvas.style.Height = gl.canvas.clientWidth;
            gl.canvas.width = gl.canvas.clientWidth * 2;
            gl.canvas.height = gl.canvas.clientWidth * 2;

            const vs = `
                attribute vec4 a_position;

                void main() {
                  gl_Position = a_position;
                }
              `;

            const fs = `
                precision highp float;

                uniform vec2 iResolution;
                uniform vec2 iMouse;
                uniform float iTime;

                #define t iTime
                #define r iResolution.xy

int mod(int x, int y)
{
float f = float(x)/float(y);
return x - y * int(floor(f));
}

vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{
    
    return a + b*cos( 6.28318*(c*t+d) );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 m = iMouse.xy/iResolution.xy;
    float zoom = pow(10., -m.x*3.);
    
    //zoom = 1./iTime;
    zoom = 0.0061;
    
    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;
    
    uv.x -= 0.02/ zoom;
    uv.y -= 0.3426/ zoom;
    
    vec2 c = uv*zoom*3.;
    c+=vec2(-0.69955, 0.37999);    
    
    vec2 z = vec2(0.);
    float iter = 0.;
    
    const float max_iter = 30.;
    
    //float t = 1.9 + sin(iTime*0.2)*1.04;
    float t = -0.25-abs(sin(iTime*0.005))/14.;
    
    float xmax = 0.;
    
    for(float i=0.; i<max_iter; i++) {
        z = vec2(z.x*z.x - z.y*z.y, t*z.x*z.y) + c;
        
        if (z.x > xmax) xmax = z.x;
                
        if (pow(z.x,z.y)>100.) break;
        
        iter++;
    }
    
    float f = iter/max_iter;

    vec3 col = vec3(f); 
    
    //col *= pal( uv.x/1.4, vec3(1.000,0.748,0.458),vec3(0.000,-0.152,0.000),vec3(1.000,1.000,1.000),vec3(0.000,0.000,0.000));
    // Output to screen
    fragColor = vec4(col,1.0);
}

                void main() {
                  mainImage(gl_FragColor, gl_FragCoord.xy);


//if ( fwidth(length(gl_FragColor)) > .01 ) {

vec4 o;
for (int k=0; k <9; k++ )
          { mainImage(o,gl_FragCoord.xy+vec2(mod(k,3)-1,k/3-1)/3.); gl_FragColor += o; }
        gl_FragColor /= 9.;

//}
                }


                
              `;

            var vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
            var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

            const program = createProgramFromSources(gl, vertexShader, fragmentShader);

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

            const resolutionLocation = gl.getUniformLocation(program, "iResolution");
            const mouseLocation = gl.getUniformLocation(program, "iMouse");
            const timeLocation = gl.getUniformLocation(program, "iTime");

            const positionBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                -1, 1,
                1, -1,
                1, 1,
            ]), gl.STATIC_DRAW);

            let requestId;
            function requestFrame() {
                if (!requestId) {
                    requestId = requestAnimationFrame(render);
                }
            }
            function cancelFrame() {
                if (requestId) {
                    cancelAnimationFrame(requestId);
                    requestId = undefined;
                }
            }

            setInterval(requestFrame, 10);

            let then = 0;
            let time = 0;
            function render(now) {
                requestId = undefined;
                now *= 0.001;
                const elapsedTime = Math.min(now - then, 0.1);
                time += elapsedTime;
                then = now;

                //webglUtils.resizeCanvasToDisplaySize(gl.canvas);
                console.log(gl.canvas.width);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.useProgram(program);

                gl.enableVertexAttribArray(positionAttributeLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                gl.vertexAttribPointer(
                    positionAttributeLocation,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0,
                );

                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(timeLocation, time);

                gl.drawArrays(
                    gl.TRIANGLES,
                    0,
                    6,
                );

                requestFrame();
            }

            requestFrame();
            requestAnimationFrame(cancelFrame);
        }

        main();

    </script>
</body>
</html>
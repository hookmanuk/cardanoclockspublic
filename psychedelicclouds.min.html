<html>
<body style="margin:0;">            
<div class="clockdiv" style="width:80%; margin:auto;">
    <canvas style="padding: 0; border-radius: 50%; position:absolute; top:0; left:0;" id="canvas"></canvas>  
    <canvas style="padding: 0; position:absolute; top:0; left:0;" id="canvasclock"></canvas>                  
</div>

    
    <script>
class renderclocksampleclock{constructor(){this.canvas=document.getElementById("canvasclock"),this.backgroundColour="rgba(0,0,0,0)",this.clockColour="#FDFFFC",this.handsColour="#FDFFFC",this.numbersType="none",this.secondHandType="handscolour",this.handsEndType="rounded",this.handsWidthType="thick",this.handsCentreType="circle",this.handsLengthType="extended",this.backgroundType="webgl",this.borderType="nothing",this.dimensionType="3d",this.hourHandType="standard",this.fps=60,this.renderframe(),this.canvasgl=document.getElementById("canvas"),this.canvasgl.width=this.ss,this.canvasgl.height=this.ss,setInterval(this.renderframe.bind(this),1e3)}drawStaticBackground(){this.ctx.fillStyle=this.backgroundColour,this.ctx.fillRect(-this.ss,-this.ss,2*this.ss,2*this.ss),this.ctx.restore()}renderframe(){this.body=document.querySelector("body");var t=this.ss;this.ss=.8*(this.body.clientWidth<this.body.clientHeight?this.body.clientWidth:this.body.clientHeight),this.ss!=t&&(this.canvas.width=this.ss,this.canvas.height=this.ss,this.ctx=this.canvas.getContext("2d"),this.radius=this.canvas.height/2,this.ctx.translate(this.radius,this.radius)),this.ctx.clearRect(-this.ss,-this.ss,2*this.ss,2*this.ss),this.drawStaticBackground(),this.drawTime()}formatNumber(t){return t.toString().padStart(2,"0")}drawTime(){var t=new Date,s=t.getHours(),i=t.getMinutes(),h=t.getSeconds();s=(s%=12)*Math.PI/6+i*Math.PI/360+h*Math.PI/21600;t.getHours(),t.getMinutes();this.ctx.save(),"3d"==this.dimensionType&&(this.ctx.shadowBlur=5,this.ctx.shadowColor="#222222",this.ctx.shadowOffsetX=-4,this.ctx.shadowOffsetY=3),"circle"!=this.handsCentreType&&"circle"!=this.handsCentreType||(this.ctx.beginPath(),this.ctx.arc(0,0,.05*this.radius,0,2*Math.PI),this.ctx.fillStyle="cutout"==this.hourHandType?this.clockColour:this.handsColour,this.ctx.fill());var e=0;"extended"!=this.handsLengthType&&"extended"!=this.handsLengthType||(e=.1*this.radius);"cutout"!=this.hourHandType&&this.drawHand(this.ctx,s,.5*this.radius*1,.03*this.radius,0,null,e),i=i*Math.PI/30+h*Math.PI/1800,this.drawHand(this.ctx,i,.7*this.radius*1,.02*this.radius,0,"cutout"==this.hourHandType?this.clockColour:this.handsColour,e),h=h*Math.PI/30,this.drawHand(this.ctx,h,.9*this.radius,.01*this.radius,0,null,.2*this.radius)}drawHand(t,s,i,h,e,a,r){if(null==a&&(a=this.handsColour),e>0)this.strokestyle=this.ctx.createRadialGradient(0,0,0,0,0,this.radius),this.strokestyle.addColorStop(0,"rgba(255, 255, 255, 0)"),this.strokestyle.addColorStop(e,"rgba(255, 255, 255, 0)"),this.strokestyle.addColorStop(e,a),this.strokestyle.addColorStop(1,a),this.ctx.strokeStyle=this.strokestyle,this.ctx.lineCap="butt";else switch(this.ctx.strokeStyle=a,"rounded"==this.handsEndType&&(this.ctx.lineCap="round"),this.handsWidthType){case"thin":h*=.5;break;case"medium":break;case"thick":h*=2}this.ctx.beginPath(),this.ctx.lineWidth=h,this.ctx.moveTo(0,0),this.ctx.rotate(s),this.ctx.lineTo(0,-i),this.ctx.stroke(),this.ctx.rotate(-s),r>0&&(this.ctx.beginPath(),this.ctx.moveTo(0,0),this.ctx.rotate(s),this.ctx.lineTo(0,r),this.ctx.stroke(),this.ctx.rotate(-s))}}new renderclocksampleclock;
    </script>    

<script>
"use strict";

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
 
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

 function createProgramFromSources(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

function main() {
  const canvas = document.querySelector("#canvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    return;
  }

  const vs = `
    attribute vec4 a_position;

    void main() {
      gl_Position = a_position;
    }
  `;

  const fs = `
    precision highp float;

    uniform vec2 iResolution;
    uniform vec2 iMouse;
    uniform float iTime;    

    #define t iTime
    #define r iResolution.xy

    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float random (in vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))
                * 43758.5453123);
}

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                        -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        
    //return 130.0 * dot(m, g);
    return 130.0 * dot(m, g) / (0.5+abs(cos(t/10.)));
}

float level(vec2 st) {
    float n = 0.0;
    for (float i = 1.0; i < 8.0; i ++) {
        float m = pow(2.0, i);
        n += snoise(st * m) * (1.0 / m);
    }
    return n * 0.5 + 0.5;
}

vec3 normal(vec2 st) {
    float d = 0.1 + abs(cos(t/10.)  *50.) * 0.001;    
    float l0 = level(st);
    float l1 = level(st + vec2(d, 0.0)); // slightly offset the x-coord
    float l2 = level(st + vec2(0.0, d)); // slightly offset the y-coord
    // return normalized vector perpendicular to the surface using the noise values as the elevation of these points
    return normalize(vec3(-(l1 - l0), -(l2 - l0), d));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 st = fragCoord.xy / iResolution.xy;
    st.x *= iResolution.x / iResolution.y;
    st.x += cos(t*0.008);
    st.y += sin(t*0.008);
    //fragColor = vec4(normal(st / abs(cos(t/10.))), 1.0);
    fragColor = vec4(normal(st), 1.0);
}

    void main() {
      mainImage(gl_FragColor, gl_FragCoord.xy);
    }
  `; 

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

  const program = createProgramFromSources(gl, vertexShader, fragmentShader);

  const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

  const resolutionLocation = gl.getUniformLocation(program, "iResolution");
  const mouseLocation = gl.getUniformLocation(program, "iMouse");
  const timeLocation = gl.getUniformLocation(program, "iTime");

  const positionBuffer = gl.createBuffer();

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1,
  ]), gl.STATIC_DRAW);

  let requestId;
  function requestFrame() {
    if (!requestId) {
      requestId = requestAnimationFrame(render);
    }
  }
  function cancelFrame() {
    if (requestId) {
      cancelAnimationFrame(requestId);
      requestId = undefined;
    }
  }

  setInterval(requestFrame, 10);         

  let then = 0;
  let time = 0;
  function render(now) {
    requestId = undefined;
    now *= 0.001;
    const elapsedTime = Math.min(now - then, 0.1);
    time += elapsedTime;
    then = now;

    //webglUtils.resizeCanvasToDisplaySize(gl.canvas);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    gl.useProgram(program);

    gl.enableVertexAttribArray(positionAttributeLocation);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    
    gl.vertexAttribPointer(
        positionAttributeLocation,
        2,
        gl.FLOAT,
        false,
        0,
        0,
    );

    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
    gl.uniform1f(timeLocation, time);

    gl.drawArrays(
        gl.TRIANGLES,
        0,
        6,
    );

    requestFrame();
  }

  requestFrame();
  requestAnimationFrame(cancelFrame);
}

main();

</script>
</body>
</html>
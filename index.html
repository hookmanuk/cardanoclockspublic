<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<head>
    <link rel="stylesheet" href="website.css"/>
     <!--icons start-->
    
    <link rel="icon" type="image/png" sizes="192x192" href="TemplateData/icon-192x192.png">
    
    <link rel="manifest" href="TemplateData/manifest.json">
   
    <meta name="theme-color" content="#000000">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <!--icons end-->

    <title>Cardano Clock</title>
    <meta name="description" content="">       

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RFSP9L3K2M"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RFSP9L3K2M');
    </script>
</head>
<body style="margin:0;">
    <div class="headerbanner">
        <img src="images\fulllogo.png" />
    </div>
    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Cardano Blockchain NFTs</h4>
            <p>
                Cardano Clocks are generated using code stored entirely on the Cardano blockchain so you will never lose access to your clock. Preview images are also stored on the peer to peer Interplanetary File System network (IPFS) for easy access.
            </p>
        </div>
        <canvas style="padding: 0;" id="canvas1"></canvas>
    </div>
    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Collection One: Analog</h4>
            <p>
                A collection of x unique analog clocks will be minted, with different styles of clock face, hands, time markers and more, including rare clock faces such as algorithmically generated animations or images
            </p>
        </div>
        <canvas style="padding: 0;" id="canvas2"></canvas>
    </div>
    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Reuseable HTML5 code</h4>
            <p>
                Each clock is generated from canvas code so that can be used inside any HTML5 compatible page or application.
            </p>
        </div>
        <canvas style="padding: 0;" id="canvas3"></canvas>
    </div>

    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Animated backgrounds</h4>
            <p>
                Some clocks have animated backgrounds using web gl shader code.
            </p>
        </div>
        <div class="clockdiv" style="width: 260px; height: 260px; margin: auto; background: black; border-radius: 50%;">
            <canvas style="padding: 0;" id="canvas4"></canvas>
            <canvas id="canvas4shader" width="256" height="256" style="top:-264px;left:0;width:100%;height:100%; position:relative; border-radius:50%;"></canvas>
        </div>
    </div>

    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>The Refresh mashups</h4>
            <p>
                Some clock backgrounds use my The Refresh NFTs
            </p>
        </div>
        <div class="clockdiv" style="width: 260px; height: 260px; margin: auto; border-radius: 50%;">
            <canvas id="canvas5refresh" width="256" height="256" style=";left:0;width:100%;height:100%;  border-radius:50%; "></canvas>
            <canvas style="padding: 0; z-index: 2; position: relative; top: -264px " id="canvas5"></canvas>
        </div>
    </div>

    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Aw0k3n algorithms mashups</h4>
            <p>
                Some clock backgrounds use my Aw0k3n algorithm NFTs
            </p>
        </div>
        <div class="clockdiv" style="width: 260px; height: 260px; margin: auto; border-radius: 50%;">
            <canvas id="canvas6awoken" width="256" height="256" style=";left:0;width:100%;height:100%;  border-radius:50%; "></canvas>
            <canvas style="padding: 0; z-index: 2; position: relative; top: -264px " id="canvas6"></canvas>
        </div>
    </div>

    <div class="clockscontainer">
        <div class="blurbcontainer">
            <h4>Custom minting</h4>
            <p>
                Some special NFTs will be minted as tokens allowing the owner to request a background of their own The Refresh or Aw0k3n algorithm!
            </p>
        </div>
        <div class="clockdiv" style="width: 260px; height: 260px; margin: auto; border-radius: 50%; background:white;">
            <img src="images\yournfthere.png" class="clockicon" />
            <canvas style="padding: 0; position: relative; top: -224px;" id="canvas7"></canvas>
        </div>
        </div>

        <div class="footericons">
            <a href="https://twitter.com/hookman1979" target="_blank"><img src="images\twitter-brands.svg" style="width:42px;"></a>
            <a href="https://discord.gg/9SQw9CxDDH" target="_blank"><img src="images\discord-brands.svg"></a>
        </div>

        <script>
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker
                    .register('sw.js')
                    .then(function () { console.log("Service Worker Registered"); });
            }
        </script>
        <script>
            class renderclocksample1 { constructor() { this.canvas = document.getElementById("canvas1"), this.ss = 300, this.backgroundColour = "rgba(0,0,0,0)", this.clockColour = "#FDFFFC", this.handsColour = "#222222", this.numbersType = "somedashes", this.secondHandType = "red", this.handsEndType = "rounded", this.handsWidthType = "thick", this.handsCentreType = "circle", this.handsLengthType = "standard", this.backgroundType = "cardano", this.borderType = "nothing", this.dimensionType = "3d", this.hourHandType = "standard", this.fps = 60, this.canvas.width = this.ss, this.canvas.height = this.ss, this.ctx = this.canvas.getContext("2d"), this.radius = this.canvas.height / 2, this.ctx.translate(this.radius, this.radius), this.radius = .85 * this.radius, setInterval(this.renderframe.bind(this), 500) } drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour, this.ctx.fillRect(-this.ss, -this.ss, 2 * this.ss, 2 * this.ss), this.ctx.restore(), this.drawFace(), this.drawNumbers() } renderframe() { this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(), this.drawTime() } formatNumber(t) { return t.toString().padStart(2, "0") } drawFace() { this.ctx.beginPath(), this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = this.clockColour, this.ctx.fill(), "cardano" == this.backgroundType && this.drawCardanoLogo() } drawNumbers() { var t, s; for (this.ctx.font = .15 * this.radius + "px arial", this.ctx.textBaseline = "middle", this.ctx.textAlign = "center", this.ctx.fillStyle = this.handsColour, s = 0; s < 12; s++)t = s * Math.PI / 6, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, s % 3 ? .91 : .87) } drawTime() { var t = new Date, s = t.getHours(), i = t.getMinutes(), h = t.getSeconds(); s = (s %= 12) * Math.PI / 6 + i * Math.PI / 360 + h * Math.PI / 21600; t.getHours(), t.getMinutes(); this.ctx.save(), this.ctx.shadowBlur = 5, this.ctx.shadowColor = "#222222", this.ctx.shadowOffsetX = -4, this.ctx.shadowOffsetY = 3, this.ctx.beginPath(), this.ctx.arc(0, 0, .05 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "cutout" == this.hourHandType ? this.clockColour : this.handsColour, this.ctx.fill(); var a = 0; "extended" != this.handsLengthType && "extended" != this.handsLengthType || (a = .1 * this.radius); var r = 1; "short" == this.handsLengthType && (r = .7), "cutout" != this.hourHandType && this.drawHand(this.ctx, s, .5 * this.radius * r, .03 * this.radius, 0, null, a), i = i * Math.PI / 30 + h * Math.PI / 1800, this.drawHand(this.ctx, i, .7 * this.radius * r, .02 * this.radius, 0, "cutout" == this.hourHandType ? this.clockColour : this.handsColour, a), h = h * Math.PI / 30, this.drawHand(this.ctx, h, .9 * this.radius, .01 * this.radius, 0, "#C71013", .2 * this.radius), this.ctx.beginPath(), this.ctx.arc(0, 0, .015 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "#C71013", this.ctx.fill() } drawHand(t, s, i, h, a, r, e) { null == r && (r = this.handsColour), a > 0 ? (this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius), this.strokestyle.addColorStop(0, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, r), this.strokestyle.addColorStop(1, r), this.ctx.strokeStyle = this.strokestyle, this.ctx.lineCap = "butt") : (this.ctx.strokeStyle = r, this.ctx.lineCap = "round", h *= 2), this.ctx.beginPath(), this.ctx.lineWidth = h, this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, -i), this.ctx.stroke(), this.ctx.rotate(-s), e > 0 && (this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, e), this.ctx.stroke(), this.ctx.rotate(-s)) } drawCardanoLogo() { this.drawCardanoRing(0, .3 * this.radius, .116 * this.radius), this.drawCardanoRing(90, .42 * this.radius, .05 * this.radius), this.drawCardanoRing(0, .52 * this.radius, .04 * this.radius), this.drawCardanoRing(90, .6 * this.radius, .033 * this.radius), this.drawCardanoRing(0, .65 * this.radius, .024 * this.radius) } drawCardanoRing(t, s, i) { for (let h = 0; h < 6; h++)this.x = 0 + Math.cos(t * Math.PI / 180) * s, this.y = 0 + Math.sin(t * Math.PI / 180) * s, t += 60, this.ctx.beginPath(), this.ctx.arc(this.x, this.y, i, 0, 2 * Math.PI), this.ctx.fillStyle = "#1F61BA", this.ctx.fill() } } new renderclocksample1;
        </script>

        <script>
            class renderclocksample2 { constructor() { this.canvas = document.getElementById("canvas2"), this.ss = 300, this.backgroundColour = "rgba(0,0,0,0)", this.clockColour = "#FDFFFC", this.handsColour = "#222222", this.numbersType = "numbers", this.secondHandType = "red", this.handsEndType = "rounded", this.handsWidthType = "thick", this.handsCentreType = "point", this.handsLengthType = "extended", this.backgroundType = "plain", this.borderType = "nothing", this.dimensionType = "3d", this.hourHandType = "cutout", this.fps = 60, this.canvas.width = this.ss, this.canvas.height = this.ss, this.ctx = this.canvas.getContext("2d"), this.radius = this.canvas.height / 2, this.ctx.translate(this.radius, this.radius), this.radius = .85 * this.radius, setInterval(this.renderframe.bind(this), 500) } drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour, this.ctx.fillRect(-this.ss, -this.ss, 2 * this.ss, 2 * this.ss), this.ctx.restore(), this.drawFace(), this.drawNumbers() } renderframe() { this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(), this.drawTime() } formatNumber(t) { return t.toString().padStart(2, "0") } drawFace() { var t; this.ctx.beginPath(), this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = this.clockColour, this.ctx.fill(), "nothing" != this.borderType && ("gradient" == this.borderType ? ((t = this.ctx.createRadialGradient(0, 0, .9 * this.radius, 0, 0, 1 * this.radius)).addColorStop(0, this.clockColour), t.addColorStop(.5, this.handsColour), t.addColorStop(1, this.clockColour), this.ctx.strokeStyle = t) : this.ctx.strokeStyle = this.handsColour, this.ctx.lineWidth = .03 * this.radius, this.ctx.stroke()), "cardano" == this.backgroundType && this.drawCardanoLogo() } drawNumbers() { var t, s; switch (this.ctx.font = .15 * this.radius + "px arial", this.ctx.textBaseline = "middle", this.ctx.textAlign = "center", this.ctx.fillStyle = this.handsColour, this.numbersType) { case "numbers": for (s = 1; s < 13; s++)t = s * Math.PI / 6, this.ctx.rotate(t), this.ctx.translate(0, .85 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(s.toString(), 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .85 * this.radius), this.ctx.rotate(-t); break; case "somedashes": for (s = 0; s < 12; s++)t = s * Math.PI / 6, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, s % 3 ? .91 : .87); break; case "alldashes": for (s = 0; s < 60; s++)t = s * Math.PI / 30, this.startdashratio = s % 15 == 0 ? .85 : s % 5 == 0 ? .88 : .92, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, this.startdashratio); break; case "numbersdashes": for (s = 0; s < 60; s++)t = s * Math.PI / 30, this.startdashratio = s % 15 == .85 ? 0 : s % 5 == 0 ? .88 : .92, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, this.startdashratio), .88 == this.startdashratio && (this.ctx.rotate(t), this.ctx.translate(0, .77 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(0 == s ? 12 : s.toString() / 5, 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .77 * this.radius), this.ctx.rotate(-t)); break; case "bits": for (s = 1; s < 13; s++)t = s * Math.PI / 6, this.ctx.rotate(t), this.ctx.translate(0, .82 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(s.toString(2).replaceAll("1", "I").padStart(4, "0"), 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .82 * this.radius), this.ctx.rotate(-t) } } drawTime() { var t = new Date, s = t.getHours(), i = t.getMinutes(), h = t.getSeconds(); s = (s %= 12) * Math.PI / 6 + i * Math.PI / 360 + h * Math.PI / 21600; var a = t.getHours() % 12 * 30 + .5 * t.getMinutes() - 90; if (this.ctx.save(), "3d" == this.dimensionType && (this.ctx.shadowBlur = 5, this.ctx.shadowColor = "#222222", this.ctx.shadowOffsetX = -4, this.ctx.shadowOffsetY = 3), "cutout" == this.hourHandType && (this.ctx.beginPath(), this.ctx.rotate(a * Math.PI / 180), this.ctx.arc(0, 0, this.radius, .09 * Math.PI, 1.91 * Math.PI), this.ctx.lineTo(0, 0), this.ctx.closePath(), this.ctx.fillStyle = this.handsColour, this.ctx.fill(), this.ctx.rotate(-a * Math.PI / 180)), "circle" != this.handsCentreType && "circle" != this.handsCentreType || (this.ctx.beginPath(), this.ctx.arc(0, 0, .05 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "cutout" == this.hourHandType ? this.clockColour : this.handsColour, this.ctx.fill()), "circle" == this.hourHandType) { this.x = Math.cos(a * Math.PI / 180) * this.radius * .6, this.y = Math.sin(a * Math.PI / 180) * this.radius * .6; var r = this.ctx.createRadialGradient(this.x + .025 * this.radius, this.y - .02 * this.radius, .01 * this.radius, this.x, this.y, .1 * this.radius); r.addColorStop(0, "white"), r.addColorStop(1, this.handsColour), this.ctx.beginPath(), this.ctx.arc(this.x, this.y, .08 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = r, this.ctx.fill() } else { var e = 0; "extended" != this.handsLengthType && "extended" != this.handsLengthType || (e = .1 * this.radius); var d = 1; switch ("short" == this.handsLengthType && (d = .7), "cutout" != this.hourHandType && this.drawHand(this.ctx, s, .5 * this.radius * d, .03 * this.radius, 0, null, e), i = i * Math.PI / 30 + h * Math.PI / 1800, this.drawHand(this.ctx, i, .7 * this.radius * d, .02 * this.radius, 0, "cutout" == this.hourHandType ? this.clockColour : this.handsColour, e), h = h * Math.PI / 30, this.secondHandType) { case "nothing": break; case "handscolour": this.drawHand(this.ctx, h, .9 * this.radius, .01 * this.radius, 0, null, .2 * this.radius); break; case "red": this.drawHand(this.ctx, h, .9 * this.radius, .01 * this.radius, 0, "#C71013", .2 * this.radius), this.ctx.beginPath(), this.ctx.arc(0, 0, .015 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "#C71013", this.ctx.fill() } } } drawHand(t, s, i, h, a, r, e) { if (null == r && (r = this.handsColour), a > 0) this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius), this.strokestyle.addColorStop(0, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, r), this.strokestyle.addColorStop(1, r), this.ctx.strokeStyle = this.strokestyle, this.ctx.lineCap = "butt"; else switch (this.ctx.strokeStyle = r, "rounded" == this.handsEndType && (this.ctx.lineCap = "round"), this.handsWidthType) { case "thin": h *= .5; break; case "medium": break; case "thick": h *= 2 }this.ctx.beginPath(), this.ctx.lineWidth = h, this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, -i), this.ctx.stroke(), this.ctx.rotate(-s), e > 0 && (this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, e), this.ctx.stroke(), this.ctx.rotate(-s)) } drawCardanoLogo() { this.drawCardanoRing(0, .3 * this.radius, .116 * this.radius), this.drawCardanoRing(90, .42 * this.radius, .05 * this.radius), this.drawCardanoRing(0, .52 * this.radius, .04 * this.radius), this.drawCardanoRing(90, .6 * this.radius, .033 * this.radius), this.drawCardanoRing(0, .65 * this.radius, .024 * this.radius) } drawCardanoRing(t, s, i) { for (let h = 0; h < 6; h++)this.x = 0 + Math.cos(t * Math.PI / 180) * s, this.y = 0 + Math.sin(t * Math.PI / 180) * s, t += 60, this.ctx.beginPath(), this.ctx.arc(this.x, this.y, i, 0, 2 * Math.PI), this.ctx.fillStyle = "#1F61BA", this.ctx.fill() } } new renderclocksample2;
        </script>

        <script>
            class renderclocksample3 { constructor() { this.canvas = document.getElementById("canvas3"), this.ss = 300, this.backgroundColour = "rgba(0,0,0,0)", this.clockColour = "#FDFFFC", this.handsColour = "#222222", this.numbersType = "bits", this.secondHandType = "nothing", this.handsEndType = "corners", this.handsWidthType = "circle", this.handsCentreType = "point", this.handsLengthType = "standard", this.backgroundType = "plain", this.borderType = "solid", this.dimensionType = "3d", this.hourHandType = "circle", this.fps = 60, this.canvas.width = this.ss, this.canvas.height = this.ss, this.ctx = this.canvas.getContext("2d"), this.radius = this.canvas.height / 2, this.ctx.translate(this.radius, this.radius), this.radius = .85 * this.radius, setInterval(this.renderframe.bind(this), 500) } drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour, this.ctx.fillRect(-this.ss, -this.ss, 2 * this.ss, 2 * this.ss), this.ctx.restore(), this.drawFace(), this.drawNumbers() } renderframe() { this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(), this.drawTime() } formatNumber(t) { return t.toString().padStart(2, "0") } drawFace() { var t; this.ctx.beginPath(), this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = this.clockColour, this.ctx.fill(), "nothing" != this.borderType && ("gradient" == this.borderType ? ((t = this.ctx.createRadialGradient(0, 0, .9 * this.radius, 0, 0, 1 * this.radius)).addColorStop(0, this.clockColour), t.addColorStop(.5, this.handsColour), t.addColorStop(1, this.clockColour), this.ctx.strokeStyle = t) : this.ctx.strokeStyle = this.handsColour, this.ctx.lineWidth = .03 * this.radius, this.ctx.stroke()), "cardano" == this.backgroundType && this.drawCardanoLogo() } drawNumbers() { var t, s; switch (this.ctx.font = .15 * this.radius + "px arial", this.ctx.textBaseline = "middle", this.ctx.textAlign = "center", this.ctx.fillStyle = this.handsColour, this.numbersType) { case "numbers": for (s = 1; s < 13; s++)t = s * Math.PI / 6, this.ctx.rotate(t), this.ctx.translate(0, .85 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(s.toString(), 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .85 * this.radius), this.ctx.rotate(-t); break; case "somedashes": for (s = 0; s < 12; s++)t = s * Math.PI / 6, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, s % 3 ? .91 : .87); break; case "alldashes": for (s = 0; s < 60; s++)t = s * Math.PI / 30, this.startdashratio = s % 15 == 0 ? .85 : s % 5 == 0 ? .88 : .92, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, this.startdashratio); break; case "numbersdashes": for (s = 0; s < 60; s++)t = s * Math.PI / 30, this.startdashratio = s % 15 == .85 ? 0 : s % 5 == 0 ? .88 : .92, this.drawHand(this.ctx, t, .95 * this.radius, .02 * this.radius, this.startdashratio), .88 == this.startdashratio && (this.ctx.rotate(t), this.ctx.translate(0, .77 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(0 == s ? 12 : s.toString() / 5, 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .77 * this.radius), this.ctx.rotate(-t)); break; case "bits": for (s = 1; s < 13; s++)t = s * Math.PI / 6, this.ctx.rotate(t), this.ctx.translate(0, .82 * -this.radius), this.ctx.rotate(-t), this.ctx.fillText(s.toString(2).replaceAll("1", "I").padStart(4, "0"), 0, 0), this.ctx.rotate(t), this.ctx.translate(0, .82 * this.radius), this.ctx.rotate(-t) } } drawTime() { var t = new Date, s = t.getHours(), i = t.getMinutes(), h = t.getSeconds(); s = (s %= 12) * Math.PI / 6 + i * Math.PI / 360 + h * Math.PI / 21600; var a = t.getHours() % 12 * 30 + .5 * t.getMinutes() - 90; if (this.ctx.save(), "3d" == this.dimensionType && (this.ctx.shadowBlur = 5, this.ctx.shadowColor = "#222222", this.ctx.shadowOffsetX = -4, this.ctx.shadowOffsetY = 3), "cutout" == this.hourHandType && (this.ctx.beginPath(), this.ctx.rotate(a * Math.PI / 180), this.ctx.arc(0, 0, this.radius, .09 * Math.PI, 1.91 * Math.PI), this.ctx.lineTo(0, 0), this.ctx.closePath(), this.ctx.fillStyle = this.handsColour, this.ctx.fill(), this.ctx.rotate(-a * Math.PI / 180)), "circle" != this.handsCentreType && "circle" != this.handsCentreType || (this.ctx.beginPath(), this.ctx.arc(0, 0, .05 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "cutout" == this.hourHandType ? this.clockColour : this.handsColour, this.ctx.fill()), "circle" == this.hourHandType) { this.x = Math.cos(a * Math.PI / 180) * this.radius * .6, this.y = Math.sin(a * Math.PI / 180) * this.radius * .6; var r = this.ctx.createRadialGradient(this.x + .025 * this.radius, this.y - .02 * this.radius, .01 * this.radius, this.x, this.y, .1 * this.radius); r.addColorStop(0, "white"), r.addColorStop(1, this.handsColour), this.ctx.beginPath(), this.ctx.arc(this.x, this.y, .08 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = r, this.ctx.fill() } else { var e = 0; "extended" != this.handsLengthType && "extended" != this.handsLengthType || (e = .1 * this.radius); var d = 1; switch ("short" == this.handsLengthType && (d = .7), "cutout" != this.hourHandType && this.drawHand(this.ctx, s, .5 * this.radius * d, .03 * this.radius, 0, null, e), i = i * Math.PI / 30 + h * Math.PI / 1800, this.drawHand(this.ctx, i, .7 * this.radius * d, .02 * this.radius, 0, "cutout" == this.hourHandType ? this.clockColour : this.handsColour, e), h = h * Math.PI / 30, this.secondHandType) { case "nothing": break; case "handscolour": this.drawHand(this.ctx, h, .9 * this.radius, .01 * this.radius, 0, null, .2 * this.radius); break; case "red": this.drawHand(this.ctx, h, .9 * this.radius, .01 * this.radius, 0, "#C71013", .2 * this.radius), this.ctx.beginPath(), this.ctx.arc(0, 0, .015 * this.radius, 0, 2 * Math.PI), this.ctx.fillStyle = "#C71013", this.ctx.fill() } } } drawHand(t, s, i, h, a, r, e) { if (null == r && (r = this.handsColour), a > 0) this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius), this.strokestyle.addColorStop(0, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, "rgba(255, 255, 255, 0)"), this.strokestyle.addColorStop(a, r), this.strokestyle.addColorStop(1, r), this.ctx.strokeStyle = this.strokestyle, this.ctx.lineCap = "butt"; else switch (this.ctx.strokeStyle = r, "rounded" == this.handsEndType && (this.ctx.lineCap = "round"), this.handsWidthType) { case "thin": h *= .5; break; case "medium": break; case "thick": h *= 2 }this.ctx.beginPath(), this.ctx.lineWidth = h, this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, -i), this.ctx.stroke(), this.ctx.rotate(-s), e > 0 && (this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.rotate(s), this.ctx.lineTo(0, e), this.ctx.stroke(), this.ctx.rotate(-s)) } drawCardanoLogo() { this.drawCardanoRing(0, .3 * this.radius, .116 * this.radius), this.drawCardanoRing(90, .42 * this.radius, .05 * this.radius), this.drawCardanoRing(0, .52 * this.radius, .04 * this.radius), this.drawCardanoRing(90, .6 * this.radius, .033 * this.radius), this.drawCardanoRing(0, .65 * this.radius, .024 * this.radius) } drawCardanoRing(t, s, i) { for (let h = 0; h < 6; h++)this.x = 0 + Math.cos(t * Math.PI / 180) * s, this.y = 0 + Math.sin(t * Math.PI / 180) * s, t += 60, this.ctx.beginPath(), this.ctx.arc(this.x, this.y, i, 0, 2 * Math.PI), this.ctx.fillStyle = "#1F61BA", this.ctx.fill() } } new renderclocksample3;
        </script>

        <script>
            class renderclocksample4 {
                constructor() { this.canvas = document.getElementById("canvas4"); this.backgroundColour = 'rgba(0,0,0,0)'; this.clockColour = '#FDFFFC'; this.handsColour = '#DDDDDD'; this.numbersType = 'roman'; this.secondHandType = 'handscolour'; this.handsEndType = 'rounded'; this.handsWidthType = 'tapered'; this.handsCentreType = 'circle'; this.handsLengthType = 'extended'; this.backgroundType = 'therefresh'; this.borderType = 'nothing'; this.dimensionType = '3d'; this.hourHandType = 'standard'; this.fps = 60; this.renderframe(); setInterval(this.renderframe.bind(this), 1000) }
                drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour; this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.ctx.restore(); this.drawFace(); this.drawNumbers() }
                renderframe() {
                    this.body = document.querySelector("body");
                    var oldss = this.ss;
                    //this.ss = (this.body.clientWidth < this.body.clientHeight ? this.body.clientWidth : this.body.clientHeight) * 0.8;
                    this.ss = "260";
                    if (this.ss != oldss) { this.canvas.width = this.ss; this.canvas.height = this.ss; this.ctx = this.canvas.getContext("2d"); this.radius = this.canvas.height / 2; this.ctx.translate(this.radius, this.radius); this.canvasc = document.querySelector(".clockdiv"); this.canvasc.style.width = this.ss; this.canvasc.style.height = this.ss }
                    this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(); this.drawTime()
                }
                formatNumber(n) { return n.toString().padStart(2, "0") }
                drawFace() {
                    var grad; if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI); this.ctx.fillStyle = this.clockColour; this.ctx.fill() }
                    if (this.borderType != "nothing") {
                        if (this.borderType == "gradient") { grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1); grad.addColorStop(0, this.clockColour); grad.addColorStop(0.5, this.handsColour); grad.addColorStop(1, this.clockColour); this.ctx.strokeStyle = grad } else { this.ctx.strokeStyle = this.handsColour }
                        this.ctx.lineWidth = this.radius * 0.03; this.ctx.stroke()
                    }
                }
                drawNumbers() {
                    var ang; var num; this.ctx.font = this.radius * 0.15 + "px arial"; this.ctx.textBaseline = "middle"; this.ctx.textAlign = "center"; this.ctx.fillStyle = "#CDCDCD"; switch (this.numbersType) {
                        case "roman": this.ctx.font = this.radius * 0.25 + "px times new roman"; for (num = 1; num < 13; num++) {
                            ang = num * Math.PI / 6; this.ctx.rotate(ang); this.ctx.translate(0, -this.radius * 0.85); var text = ""; var width = 0.11; switch (num) {
                                case 1:
                                    text = " I ";
                                    break;
                                case 2:
                                    text = "II ";
                                    break;
                                case 3:
                                    text = "III";
                                    break;
                                case 4:
                                    text = "IV";
                                    break;
                                case 5:
                                    text = " V ";
                                    break;
                                case 6:
                                    text = "VI";
                                    break;
                                case 7:
                                    text = "VII";
                                    break;
                                case 8:
                                    text = "VIII";
                                    width = 0.15;
                                    break;
                                case 9:
                                    text = "IX ";
                                    break;
                                case 10:
                                    text = " X ";
                                    break;
                                case 11:
                                    text = "XI ";
                                    break;
                                case 12:
                                    text = "XII";
                                    break;
                                default:
                                    break;
                            }
                            this.ctx.fillText(text, 0, 0, this.radius * width); this.ctx.rotate(-ang); this.ctx.rotate(ang); this.ctx.translate(0, this.radius * 0.85); this.ctx.rotate(-ang)
                        }
                            break; case "nothing": break
                    }
                }
                drawTime() {
                    var now = new Date(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); hour = hour % 12; hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60)); var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90; this.ctx.save(); if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -4; this.ctx.shadowOffsetY = 3 }
                    if (this.handsCentreType == "circle" || this.handsCentreType == "circle") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI); this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour); this.ctx.fill() }
                    var extension = 0; if (this.handsLengthType == "extended" || this.handsLengthType == "extended") { extension = this.radius * 0.1 }
                    var lengthratio = 1; if (this.handsLengthType == "short") { lengthratio = 0.7 }
                    if (this.hourHandType != "cutout") { this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension) }
                    minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)); this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension); second = (second * Math.PI / 30); switch (this.secondHandType) { case 'nothing': break; case 'handscolour': this.drawHand(this.ctx, second, this.radius * 0.8, this.radius * 0.01, 0, '#DDDDDD', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#DDDDDD'; this.ctx.fill(); break; case 'red': this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#C71013'; this.ctx.fill(); break; default: break }
                }
                drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                    if (colour == null) { colour = this.handsColour }
                    if (transparentratio > 0) { this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius); this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, colour); this.strokestyle.addColorStop(1, colour); this.ctx.strokeStyle = this.strokestyle; this.ctx.lineCap = "butt" } else {
                        this.ctx.strokeStyle = colour; if (this.handsEndType == 'rounded') { this.ctx.lineCap = "round" }
                        switch (this.handsWidthType) { case "thin": width = width * 0.5; break; case "medium": break; case "thick": width = width * 2; break; default: break }
                    }
                    this.ctx.beginPath(); this.ctx.lineWidth = width; this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, -length); this.ctx.stroke(); this.ctx.rotate(-pos); if (neglength > 0) { this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, neglength); this.ctx.stroke(); this.ctx.rotate(-pos) }
                }
            }
            new renderclocksample4()
        </script>

        <script>
            "use strict";

            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (success) {
                    return shader;
                }

                console.log(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
            }

            function createProgramFromSources(gl, vertexShader, fragmentShader) {
                var program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                var success = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (success) {
                    return program;
                }

                console.log(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
            }

            function main() {
                const canvas = document.querySelector("#canvas4shader");
                const gl = canvas.getContext("webgl");
                if (!gl) {
                    return;
                }

                const vs = `
                                                        attribute vec4 a_position;

                                                        void main() {
                                                          gl_Position = a_position;
                                                        }
                                                      `;

                const fs = `
                                                        precision highp float;

                                                        uniform vec2 iResolution;
                                                        uniform vec2 iMouse;
                                                        uniform float iTime;

                                                        #define t iTime
                                                        #define r iResolution.xy

                                                        highp float rand(vec2 co)
                                                        {
                                                            highp float a = 12.9898;
                                                            highp float b = 78.233;
                                                            highp float c = 43758.5453;
                                                            highp float dt= dot(co.xy ,vec2(a,b));
                                                            highp float sn= mod(dt,3.14);
                                                            return fract(sin(sn) * c);
                                                        }

                                                        const float animSpeed = 0.06;

                                                        float getWaveHeight(int waveIndex)
                                                        {
                                                            return 1.0;
                                                        }

                                                        float getWaveLength(int waveIndex)
                                                        {
                                                            const float minWavelength = 1.0;
                                                            const float maxWavelength = 25.0;

                                                            return minWavelength + ((maxWavelength-minWavelength) * rand(vec2(float(waveIndex), 42.0)));
                                                        }

                                                        float getSpeed(int waveIndex)
                                                        {
                                                            const float minSpeed = 0.01;
                                                            const float maxSpeed = 0.16;

                                                            return (minSpeed + ((maxSpeed-minSpeed) * rand(vec2(float(waveIndex), 420.0))))*animSpeed;
                                                        }

                                                        float getAngle(int waveIndex)
                                                        {
                                                            if(waveIndex == 0) // just makes it look a little nicer.
                                                            {
                                                                return 0.0;
                                                            }

                                                            return rand(vec2(float(waveIndex), 69.0)) * 3.14 * 2.0;
                                                        }

                                                        float getHeightAtPoint(int waveIndex,vec2 uv)
                                                        {
                                                            float angle = getAngle(waveIndex);
                                                            float speed = getSpeed(waveIndex);

                                                            float xMag = cos(angle);
                                                            float yMag = sin(angle);

                                                            float height = cos(((xMag*uv.x)+(yMag*uv.y)+(iTime*speed))*getWaveLength(waveIndex)) + 1.0;

                                                            return (height/2.0)*getWaveHeight(waveIndex);
                                                        }

                                                        void mainImage( out vec4 fragColor, in vec2 fragCoord )
                                                        {
                                                            // Number of layers (cos waves on top of each other).
                                                            const int numLayers = 9;

                                                            // For calculating the normal, which adjust all lighting.
                                                            const float heightMulti = 100.0;
                                                            const float xyMulti = 60.0;

                                                            // Lighting Params.
                                                            const float specularPower = 2.0;
                                                            const vec3 ambient = vec3(0.1, 0.1, 0.1);
                                                            const vec3 light = vec3(0.1, 0.2, 0.5);
                                                            const vec3 spec = vec3(1.0, 1.0, 1.0);


                                                            vec2 uv = fragCoord/iResolution.xy;

                                                            float height = 0.0;

                                                            float distToSample = 0.01;
                                                            vec4 surroundingHeight = vec4(0.0,0.0,0.0,0.0);

                                                            for(int layer = 0; layer < numLayers; ++layer)
                                                            {
                                                                height += getHeightAtPoint(layer, uv);

                                                                surroundingHeight.x += getHeightAtPoint(layer, uv + vec2(distToSample,0.0));
                                                                surroundingHeight.y += getHeightAtPoint(layer, uv + vec2(-distToSample,0.0));
                                                                surroundingHeight.z += getHeightAtPoint(layer, uv + vec2(0.0,distToSample));
                                                                surroundingHeight.w += getHeightAtPoint(layer, uv + vec2(0.0,-distToSample));
                                                            }

                                                            surroundingHeight /= float(numLayers);

                                                            float sampleDeltaPosInWorldSpace = xyMulti * distToSample;

                                                            vec3 lightDir = normalize(vec3(0.2, 0.1, 0.6));
                                                            vec3 cameraDir = normalize(vec3(-0.2, -0.1, 0.6));


                                                            vec3 p0 = vec3(sampleDeltaPosInWorldSpace, 0.0, surroundingHeight.x * heightMulti);
                                                            vec3 p1 = vec3(-sampleDeltaPosInWorldSpace, 0.0, surroundingHeight.y * heightMulti);
                                                            vec3 p2 = vec3(0.0, sampleDeltaPosInWorldSpace, surroundingHeight.z * heightMulti);

                                                            vec3 normal = normalize(cross(p2-p0, p1-p0));

                                                            vec3 lightReflect = normalize(-reflect(lightDir, normal));



                                                            float lightStrength = clamp(dot(lightDir, normal), 0.0, 1.0);
                                                            float specStrength = pow(clamp(dot(lightReflect, cameraDir),0.0,1.0),specularPower);

                                                            specStrength = clamp(specStrength, 0.0, 1.0);


                                                            fragColor.rgb = ambient + (light*lightStrength) + (spec*specStrength);


                                                            //Debug Vars!
                                                            //fragColor = vec4(height, height, height, 1.0);
                                                            //fragColor = vec4(normal.x, normal.y, normal.z, 1.0);
                                                            //fragColor = vec4(surroundingHeight.x, surroundingHeight.y, surroundingHeight.z, 1.0);
                                                        }

                                                        void main() {
                                                          mainImage(gl_FragColor, gl_FragCoord.xy);
                                                        }
                                                      `;

                var vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
                var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

                const program = createProgramFromSources(gl, vertexShader, fragmentShader);

                const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

                const resolutionLocation = gl.getUniformLocation(program, "iResolution");
                const mouseLocation = gl.getUniformLocation(program, "iMouse");
                const timeLocation = gl.getUniformLocation(program, "iTime");

                const positionBuffer = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,
                    1, -1,
                    -1, 1,
                    -1, 1,
                    1, -1,
                    1, 1,
                ]), gl.STATIC_DRAW);

                let requestId;
                function requestFrame() {
                    if (!requestId) {
                        requestId = requestAnimationFrame(render);
                    }
                }
                function cancelFrame() {
                    if (requestId) {
                        cancelAnimationFrame(requestId);
                        requestId = undefined;
                    }
                }

                setInterval(requestFrame, 10);

                let then = 0;
                let time = 0;
                function render(now) {
                    requestId = undefined;
                    now *= 0.001;
                    const elapsedTime = Math.min(now - then, 0.1);
                    time += elapsedTime;
                    then = now;

                    //webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                    gl.useProgram(program);

                    gl.enableVertexAttribArray(positionAttributeLocation);

                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                    gl.vertexAttribPointer(
                        positionAttributeLocation,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0,
                    );

                    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                    gl.uniform1f(timeLocation, time);

                    gl.drawArrays(
                        gl.TRIANGLES,
                        0,
                        6,
                    );

                    requestFrame();
                }

                requestFrame();
                requestAnimationFrame(cancelFrame);
            }

            main();

        </script>

        <script>
            class renderclocksample5 {
                constructor() {

                    this.canvas = document.getElementById("canvas5");

                    this.backgroundColour = 'rgba(0,0,0,0)';
                    this.clockColour = '#FDFFFC';
                    this.handsColour = '#FDFFFC';
                    this.numbersType = 'none';
                    this.secondHandType = 'handscolour';
                    this.handsEndType = 'rounded';
                    this.handsWidthType = 'tapered';
                    this.handsCentreType = 'circle';
                    this.handsLengthType = 'extended';
                    this.backgroundType = 'therefresh';
                    this.borderType = 'nothing';
                    this.dimensionType = '3d';
                    this.hourHandType = 'standard';

                    this.fps = 60;

                    //this.radius = this.radius * 0.85;
                    this.renderframe();

                    if (this.backgroundType == "therefresh") {
                        this.updateTheRefresh();
                        setInterval(this.renderframe.bind(this), 1000);
                        setInterval(this.updateTheRefresh.bind(this), 10000);
                    }
                    else {
                        setInterval(this.renderframe.bind(this), 1000);
                    }
                }

                drawStaticBackground() {
                    //ctx.arc(0, 0, radius, 0 , ss * Math.PI);
                    this.ctx.fillStyle = this.backgroundColour;
                    this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2);
                    this.ctx.restore();
                    this.drawFace();
                    this.drawNumbers();
                }

                renderframe() {
                    this.body = document.querySelector("body");
                    var oldss = this.ss;
                    this.ss = "260";
                    if (this.ss != oldss) {
                        this.canvas.width = this.ss;
                        this.canvas.height = this.ss;
                        this.ctx = this.canvas.getContext("2d");
                        this.radius = this.canvas.height / 2;
                        this.ctx.translate(this.radius, this.radius);

                        //if (this.backgroundType = 'fractal')
                        //{
                        //    setTimeout(this.updateFractal.bind(this, 1), 1);
                        //}
                        if (this.backgroundType = 'therefresh') {
                            setTimeout(this.updateTheRefresh.bind(this, 1), 1);
                        }
                    }
                    //this.canvas.style.marginTop = "-" + this.ss * 0.8 + "px"; //account for 20% margin

                    this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2);
                    this.drawStaticBackground();
                    this.drawTime();
                }

                formatNumber(n) {
                    return n.toString().padStart(2, "0");
                }



                drawFace() {
                    var grad;

                    //centre
                    if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") {
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI);
                        this.ctx.fillStyle = this.clockColour;
                        this.ctx.fill();
                    }


                    //border
                    if (this.borderType != "nothing") {
                        if (this.borderType == "gradient") {
                            grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1);
                            grad.addColorStop(0, this.clockColour);
                            grad.addColorStop(0.5, this.handsColour);
                            grad.addColorStop(1, this.clockColour);
                            this.ctx.strokeStyle = grad;
                        }
                        else {
                            this.ctx.strokeStyle = this.handsColour;
                        }
                        this.ctx.lineWidth = this.radius * 0.03;
                        this.ctx.stroke();
                    }


                    if (this.backgroundType == "cardano") {
                        this.drawCardanoLogo();
                    }

                    //border
                    //grad = ctx.createRadialGradient(0, 0 ,radius * 0.95, 0, 0, radius * 1.05);
                    //grad.addColorStop(0, clockColour);
                    //grad.addColorStop(0.5, 'white');
                    //grad.addColorStop(1, clockColour);
                    //ctx.strokeStyle = grad;
                    //ctx.lineWidth = radius*0.1;
                    //ctx.stroke();

                    //ctx.beginPath();
                    //ctx.arc(0, 0, radius * 0.1, 0, 2 * Math.PI);
                    //ctx.fillStyle = clockColour;
                    //ctx.fill();
                }

                drawNumbers() {
                    var ang;
                    var num;
                    this.ctx.font = this.radius * 0.15 + "px arial";
                    this.ctx.textBaseline = "middle";
                    this.ctx.textAlign = "center";
                    this.ctx.fillStyle = this.handsColour;

                    switch (this.numbersType) {
                        case "numbers":
                            for (num = 1; num < 13; num++) {
                                ang = num * Math.PI / 6;
                                this.ctx.rotate(ang);
                                this.ctx.translate(0, -this.radius * 0.85);
                                this.ctx.rotate(-ang);
                                this.ctx.fillText(num.toString(), 0, 0);
                                this.ctx.rotate(ang);
                                this.ctx.translate(0, this.radius * 0.85);
                                this.ctx.rotate(-ang);
                            }
                            break;
                        case "somedashes":
                            for (num = 0; num < 12; num++) {
                                ang = num * Math.PI / 6;
                                this.drawHand(this.ctx, ang, this.radius * 0.95, this.radius * 0.02, (num % 3 ? 0.91 : 0.87));
                            }
                            break;
                        case "alldashes":
                            for (num = 0; num < 60; num++) {
                                ang = num * Math.PI / 30;
                                this.startdashratio = (num % 15 == 0 ? 0.85 : (num % 5 == 0 ? 0.88 : 0.92));
                                this.drawHand(this.ctx, ang, this.radius * 0.95, this.radius * 0.02, this.startdashratio);
                            }
                            break;
                        case "numbersdashes":
                            for (num = 0; num < 60; num++) {
                                ang = num * Math.PI / 30;
                                this.startdashratio = (num % 15 == 0.85 ? 0 : (num % 5 == 0 ? 0.88 : 0.92));

                                this.drawHand(this.ctx, ang, this.radius * 0.95, this.radius * 0.02, this.startdashratio);
                                if (this.startdashratio == 0.88) {
                                    this.ctx.rotate(ang);
                                    this.ctx.translate(0, -this.radius * 0.77);
                                    this.ctx.rotate(-ang);
                                    this.ctx.fillText((num == 0 ? 12 : num.toString() / 5), 0, 0);
                                    this.ctx.rotate(ang);
                                    this.ctx.translate(0, this.radius * 0.77);
                                    this.ctx.rotate(-ang);
                                }
                            }
                            break;
                        case "bits":
                            for (num = 1; num < 13; num++) {
                                ang = num * Math.PI / 6;
                                this.ctx.rotate(ang);
                                this.ctx.translate(0, -this.radius * 0.82);
                                this.ctx.rotate(-ang);
                                this.ctx.fillText(num.toString(2).replaceAll('1', 'I').padStart(4, '0'), 0, 0);
                                this.ctx.rotate(ang);
                                this.ctx.translate(0, this.radius * 0.82);
                                this.ctx.rotate(-ang);
                            }
                            break;
                        case "nothing":
                            break;
                    }
                }

                drawTime() {
                    var now = new Date();
                    var hour = now.getHours();
                    var minute = now.getMinutes();
                    var second = now.getSeconds();
                    //hour
                    hour = hour % 12;
                    hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60));
                    var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90;

                    this.ctx.save();
                    if (this.dimensionType == "3d") {
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#222222';
                        this.ctx.shadowOffsetX = -4;
                        this.ctx.shadowOffsetY = 3;
                    }

                    if (this.hourHandType == "cutout") {
                        this.ctx.beginPath();
                        this.ctx.rotate(ang * Math.PI / 180);
                        this.ctx.arc(0, 0, this.radius, 0.09 * Math.PI, 1.91 * Math.PI);
                        this.ctx.lineTo(0, 0);
                        this.ctx.closePath();
                        this.ctx.fillStyle = this.handsColour;
                        this.ctx.fill();
                        this.ctx.rotate(-ang * Math.PI / 180);
                    }

                    //middle circle
                    if (this.handsCentreType == "circle" || this.handsCentreType == "circle") {
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI);
                        this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour);
                        this.ctx.fill();
                    }

                    if (this.hourHandType == "circle") {
                        this.x = Math.cos(ang * Math.PI / 180) * this.radius * 0.6;
                        this.y = Math.sin(ang * Math.PI / 180) * this.radius * 0.6;

                        var gradient = this.ctx.createRadialGradient(this.x + this.radius * 0.025, this.y - this.radius * 0.02, this.radius * 0.01, this.x, this.y, this.radius * 0.1);
                        gradient.addColorStop(0, 'white');
                        gradient.addColorStop(1, this.handsColour);
                        this.ctx.beginPath();
                        this.ctx.arc(this.x, this.y, this.radius * 0.08, 0, 2 * Math.PI);
                        this.ctx.fillStyle = gradient;
                        this.ctx.fill();


                        //this.ctx.restore();
                    }
                    else {
                        var extension = 0;
                        if (this.handsLengthType == "extended" || this.handsLengthType == "extended") {
                            extension = this.radius * 0.1;
                        }
                        var lengthratio = 1;
                        if (this.handsLengthType == "short") {
                            lengthratio = 0.7;
                        }

                        if (this.hourHandType != "cutout") {
                            this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension);
                        }

                        //minute
                        minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60));
                        this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension);
                        // second
                        second = (second * Math.PI / 30);
                        switch (this.secondHandType) {
                            case 'nothing':
                                break;
                            case 'handscolour':
                                this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, null, this.radius * 0.2);
                                break;
                            case 'red':
                                this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2);
                                //middle circle
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI);
                                this.ctx.fillStyle = '#C71013';
                                this.ctx.fill();
                                break;
                            default:
                                break;
                        }
                    }
                }

                drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                    //ctx.strokeStyle = getHandsColour();
                    //ctx.strokeStyle = "#FF0000";
                    if (colour == null) {
                        colour = this.handsColour;
                    }
                    if (transparentratio > 0) {
                        this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                        this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)');
                        this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)');
                        this.strokestyle.addColorStop(transparentratio, colour);
                        //strokestyle.addColorStop(0.5 , 'rgba(255, 255, 255, 0)');
                        //strokestyle.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                        this.strokestyle.addColorStop(1, colour);
                        this.ctx.strokeStyle = this.strokestyle;
                        this.ctx.lineCap = "butt";
                    }
                    else {
                        this.ctx.strokeStyle = colour;
                        if (this.handsEndType == 'rounded') {
                            this.ctx.lineCap = "round";
                        }
                        switch (this.handsWidthType) {
                            case "thin":
                                width = width * 0.5;
                                break;
                            case "medium":
                                break;
                            case "thick":
                                width = width * 2;
                                break;
                            default:
                                break;
                        }
                    }

                    this.ctx.beginPath();
                    this.ctx.lineWidth = width;
                    this.ctx.moveTo(0, 0);
                    this.ctx.rotate(pos);
                    this.ctx.lineTo(0, -length);
                    this.ctx.stroke();
                    this.ctx.rotate(-pos);

                    if (neglength > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, 0);
                        this.ctx.rotate(pos);
                        this.ctx.lineTo(0, neglength);
                        this.ctx.stroke();
                        this.ctx.rotate(-pos);
                    }

                }

                drawCardanoLogo() {
                    this.drawCardanoRing(0, this.radius * 0.3, this.radius * 0.116);
                    this.drawCardanoRing(90, this.radius * 0.42, this.radius * 0.05);
                    this.drawCardanoRing(0, this.radius * 0.52, this.radius * 0.04);
                    this.drawCardanoRing(90, this.radius * 0.60, this.radius * 0.033);
                    this.drawCardanoRing(0, this.radius * 0.65, this.radius * 0.024);
                }

                drawCardanoRing(startangle, distance, circlesize) {
                    //var x = Math.cos(-90 * Math.PI / 180) * distance;
                    //var y = Math.sin(-90 * Math.PI / 180) * distance;

                    for (let i = 0; i < 6; i++) {
                        this.x = 0 + Math.cos(startangle * Math.PI / 180) * distance;
                        this.y = 0 + Math.sin(startangle * Math.PI / 180) * distance;

                        startangle = startangle + 60;

                        this.ctx.beginPath();
                        this.ctx.arc(this.x, this.y, circlesize, 0, 2 * Math.PI);
                        this.ctx.fillStyle = '#1F61BA';
                        this.ctx.fill();
                    }



                }

                initFractal() {
                    this.creal = -.8;
                    this.cimag = .156;
                    this.frame = Math.floor(Math.random() * 1000);

                    var x;
                    var y;
                    var color;
                    this.pallette = [];

                    for (x = 0; x < 9; x++) // this loop populates the color pallette array
                    {
                        color = (31 * x).toString(16); // convert the number to hex
                        if (color.length == 1) color = '0' + color;  // add a zero in front if only one hex digit

                        var lowcolor = (279 - 31 * x).toString(16);
                        if (lowcolor.length == 1) lowcolor = '0' + lowcolor;
                        this.pallette[x] = '#' + lowcolor + lowcolor + 'ff'; // colors 0-8: the Red and Green components change, Blue=FF
                        this.pallette[x + 8] = '#2299' + color;      // colors 8-16: the Blue component changes, Red and Green=FF
                        this.pallette[17 + x] = "#" + color + '2299';  // colors 17-25: the Red component changes, Green and Blue=0
                    }
                }

                drawFractal() {
                    this.canvasfractal = document.getElementById("canvas5fractal");

                    this.canvasfractal.width = this.ss;
                    this.canvasfractal.height = this.ss;
                    this.ctxfractal = this.canvasfractal.getContext("2d");
                    var x = 0;
                    var y = 0;
                    var xt = 0;
                    var res = 2;

                    this.ctxfractal.clearRect(0, 0, this.ss, this.ss);
                    this.ctxfractal.beginPath();

                    for (y = 0; y < this.ss * res; y++) {
                        for (x = 0; x < this.ss * res; x++) {
                            var cx = -2 + x / (110 / 450 * this.ss) / res;
                            var cy = -2 + y / (110 / 450 * this.ss) / res;
                            var i = 0;

                            do {
                                xt = cx * cx - cy * cy + this.creal;
                                cy = 2 * cx * cy + this.cimag;
                                cx = xt;
                                i++;
                            }
                            while ((cx * cx + cy * cy < 4) && i < 25);

                            i = i.toString(16);

                            this.ctxfractal.beginPath();
                            this.ctxfractal.rect(x / res, y / res, 1 / res, 1 / res);

                            this.ctxfractal.fillStyle = this.pallette[i];
                            this.ctxfractal.fill();
                        }
                    }
                }

                updateFractal(interval) {
                    this.frame = this.frame + interval;        // increase the number of the frame
                    this.creal = -.8 + .6 * Math.sin(this.frame / (3.14 * 20));    // calculate the new coordinates
                    this.cimag = .156 + .4 * Math.cos(this.frame / (3.14 * 40));   // of the c point
                    this.drawFractal();
                }

                updateTheRefresh() {
                    this.canvasrefresh = document.getElementById('canvas5refresh');
                    this.canvasrefresh.width = this.ss;
                    this.canvasrefresh.height = this.ss;
                    //canvas.width =550;
                    //canvas.height = 550;
                    //canvas.style.width = '100vw';
                    //canvas.style.height = '100vh';
                    this.canvasrefresh.getContext('2d').scale(2, 2);


                    var c = document.getElementById("canvas5refresh");
                    var ctx = c.getContext("2d");
                    var grd = ctx.createLinearGradient(0, 0, Math.floor(Math.random() * this.ss), Math.floor(Math.random() * this.ss));
                    grd.addColorStop(Math.random(), "#f50c0c");
                    grd.addColorStop(Math.random(), "#ef5c0c");
                    grd.addColorStop(Math.random(), "#eb7c08");
                    grd.addColorStop(Math.random(), "#edb404");
                    grd.addColorStop(Math.random(), "#ffdc77");

                    ctx.fillStyle = grd;
                    ctx.fillRect(-this.ss / 2, -this.ss / 2, this.ss, this.ss);

                    var c = document.getElementById("canvas5refresh");
                    var cxt = c.getContext("2d");
                    var centerX = Math.floor(Math.random() * 200 / 550 * this.ss);
                    var centerY = Math.floor(Math.random() * 350 / 550 * this.ss);
                    cxt.moveTo(centerX, centerY);

                    var gap = Math.floor(Math.random() * 1) + .005; // increase this for spacing between spiral lines also bigger smaller
                    var STEPS_PER_ROTATION = Math.floor(Math.random() * 500) + 1; // increasing this makes the curve smoother

                    var increment = Math.floor(Math.random() * 400) + .01 * Math.PI / STEPS_PER_ROTATION;//lower=darker
                    var theta = increment;
                    while (theta < Math.floor(Math.random() * 150) + 35000) {//bigger or smaller
                        var newX = centerX + theta * Math.cos(theta) * gap;
                        var newY = centerY + theta * Math.sin(theta) * gap;
                        cxt.lineTo(newX, newY);
                        theta = theta + increment;
                    }
                    ctx.strokeStyle = "#000000";
                    ctx.lineWidth = .5;
                    ctx.stroke(); // draw
                }
            }

            new renderclocksample5();
        </script>

        <script>
            var canvasc = document.querySelector(".clockdiv");

            var body = document.querySelector("body");
            var ss = "260";
            canvasc.style.width = ss;
            canvasc.style.height = ss;
        </script>
        <script>!function () { "use strict"; var w = .5 * (Math.sqrt(3) - 1), c = (3 - Math.sqrt(3)) / 6, N = 1 / 6; function r(r) { r = "function" == typeof r ? r : r ? alea(r) : Math.random, this.p = e(r), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512); for (var t = 0; t < 512; t++)this.perm[t] = this.p[255 & t], this.permMod12[t] = this.perm[t] % 12 } function e(r) { for (var t = new Uint8Array(256), e = 0; e < 256; e++)t[e] = e; for (e = 0; e < 255; e++) { var o = e + ~~(r() * (256 - e)), n = t[e]; t[e] = t[o], t[o] = n } return t } Math.sqrt(5), Math.sqrt(5), r.prototype = { grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]), grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]), noise2D: function (r, t) { var e, o = this.permMod12, n = this.perm, i = this.grad3, a = 0, f = 0, s = 0, h = (r + t) * w, d = Math.floor(r + h), p = Math.floor(t + h), u = r - (d - (y = (d + p) * c)), m = t - (p - y), M = m < u ? (e = 1, 0) : (e = 0, 1), l = u - e + c, h = m - M + c, r = u - 1 + 2 * c, t = m - 1 + 2 * c, y = 255 & d, d = 255 & p; return 70 * ((a = 0 <= (p = .5 - u * u - m * m) ? (p *= p) * p * (i[p = 3 * o[y + n[d]]] * u + i[1 + p] * m) : a) + (f = 0 <= (m = .5 - l * l - h * h) ? (m *= m) * m * (i[M = 3 * o[y + e + n[d + M]]] * l + i[1 + M] * h) : f) + (s = 0 <= (h = .5 - r * r - t * t) ? (h *= h) * h * (i[d = 3 * o[1 + y + n[1 + d]]] * r + i[1 + d] * t) : s)) }, noise3D: function (r, t, e) { var o, n, i, a, f, s = this.permMod12, h = this.perm, d = this.grad3, p = (r + t + e) * (1 / 3), u = ((b = Math.floor(r + p)) + (D = Math.floor(t + p)) + (F = Math.floor(e + p))) * N, m = r - (b - u), M = t - (D - u), l = e - (F - u), y = M <= m ? l <= M ? (a = i = o = 1, f = n = 0) : i = l <= m ? (a = f = n = 0, o = 1) : (a = n = o = 0, f = 1) : M < l ? (i = n = o = 0, a = f = 1) : m < l ? (i = f = o = 0, a = n = 1) : (a = i = n = 1, f = o = 0), w = m - o + N, c = M - n + N, v = l - f + N, A = m - i + 2 * N, g = M - a + 2 * N, q = l - y + 2 * N, x = m - 1 + .5, U = M - 1 + .5, r = 255 & b, t = 255 & D, e = 255 & F, b = .6 - w * w - c * c - v * v, D = .6 - A * A - g * g - q * q, F = .6 - x * x - U * U - (p = l - 1 + .5) * p; return 32 * (((u = .6 - m * m - M * M - l * l) < 0 ? 0 : (u *= u) * u * (d[u = 3 * s[r + h[t + h[e]]]] * m + d[1 + u] * M + d[2 + u] * l)) + (b < 0 ? 0 : (b *= b) * b * (d[f = 3 * s[r + o + h[t + n + h[e + f]]]] * w + d[1 + f] * c + d[2 + f] * v)) + (D < 0 ? 0 : (D *= D) * D * (d[y = 3 * s[r + i + h[t + a + h[e + y]]]] * A + d[1 + y] * g + d[2 + y] * q)) + (F < 0 ? 0 : (F *= F) * F * (d[e = 3 * s[1 + r + h[1 + t + h[1 + e]]]] * x + d[1 + e] * U + d[2 + e] * p))) } }, r._buildPermutationTable = e, "undefined" != typeof define && define.amd && define(function () { return r }), "undefined" != typeof exports ? exports.SimplexNoise = r : "undefined" != typeof window && (window.SimplexNoise = r) }()</script>
        <script>var simplex = new SimplexNoise, canvas = document.getElementById("canvas6awoken"), ctx = canvas.getContext("2d"), imgdata = ctx.getImageData(0, 0, 256, 256), data = imgdata.data, t = 0, dna1 = 377, dna2 = 619, dna3 = 355, dna4 = 113, dna5 = 3.7, dna6 = 45, dna7 = .48, dna8 = .93, dna9 = 416, dna10 = 666, dna11 = 77, dna12 = 71, dna13 = 207, void1 = 115, void2 = 258, void3 = .5506283492497344; window.setInterval(function () { for (var a = 0; a < 256; a++)for (var d = 0; d < 256; d++) { var n = simplex.noise3D(a / dna1, d / dna2, t / dna9) * dna5 + dna7, e = simplex.noise3D(a / dna3, d / dna4, t / dna10) * dna6 + dna8, i = 0, i = 10 < dna12 ? n * dna11 : n * e * dna11, o = 0, o = 0 === dna11 || 0 === dna12 ? n * e * dna13 : dna13, v = 0, v = void3 < .01 ? 800 * simplex.noise3D(a / void1, d / void2, t / dna9) + dna7 : 255; data[4 * (a + 256 * d) + 0] = i, data[4 * (a + 256 * d) + 1] = n * e * dna12, data[4 * (a + 256 * d) + 2] = o, data[4 * (a + 256 * d) + 3] = v } t++, ctx.putImageData(imgdata, 0, 0) }, 1e3 / 60)</script>
        <script>
            class renderclocksample6 {
                constructor() { this.canvas = document.getElementById("canvas6"); this.backgroundColour = 'rgba(0,0,0,0)'; this.clockColour = '#FDFFFC'; this.handsColour = '#FFFFFF'; this.numbersType = 'roman'; this.secondHandType = 'handscolour'; this.handsEndType = 'rounded'; this.handsWidthType = 'tapered'; this.handsCentreType = 'circle'; this.handsLengthType = 'extended'; this.backgroundType = 'therefresh'; this.borderType = 'nothing'; this.dimensionType = '3d'; this.hourHandType = 'standard'; this.fps = 60; this.renderframe(); setInterval(this.renderframe.bind(this), 1000) }
                drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour; this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.ctx.restore(); this.drawFace(); this.drawNumbers() }
                renderframe() {
                    this.body = document.querySelector("body");
                    var oldss = this.ss;
                    this.ss = "260";
                    if (this.ss != oldss) { this.canvas.width = this.ss; this.canvas.height = this.ss; this.ctx = this.canvas.getContext("2d"); this.radius = this.canvas.height / 2; this.ctx.translate(this.radius, this.radius); this.canvasc = document.querySelector(".clockdiv"); this.canvasc.style.width = this.ss; this.canvasc.style.height = this.ss }
                    this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(); this.drawTime()
                }
                formatNumber(n) { return n.toString().padStart(2, "0") }
                drawFace() {
                    var grad; if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI); this.ctx.fillStyle = this.clockColour; this.ctx.fill() }
                    if (this.borderType != "nothing") {
                        if (this.borderType == "gradient") { grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1); grad.addColorStop(0, this.clockColour); grad.addColorStop(0.5, this.handsColour); grad.addColorStop(1, this.clockColour); this.ctx.strokeStyle = grad } else { this.ctx.strokeStyle = this.handsColour }
                        this.ctx.lineWidth = this.radius * 0.03; this.ctx.stroke()
                    }
                }
                drawNumbers() {
                    var ang; var num; this.ctx.font = this.radius * 0.15 + "px arial"; this.ctx.textBaseline = "middle"; this.ctx.textAlign = "center"; this.ctx.fillStyle = "#FFFFFF"; switch (this.numbersType) {
                        case "roman": this.ctx.font = this.radius * 0.25 + "px times new roman"; for (num = 1; num < 13; num++) {
                            ang = num * Math.PI / 6; this.ctx.rotate(ang); this.ctx.translate(0, -this.radius * 0.85); var text = ""; var width = 0.11; switch (num) {
                                case 1:
                                    //text = " I ";
                                    break;
                                case 2:
                                    //text = "II ";
                                    break;
                                case 3:
                                    text = "III";
                                    break;
                                case 4:
                                    //text = "IV";
                                    break;
                                case 5:
                                    //text = " V ";
                                    break;
                                case 6:
                                    text = "VI";
                                    break;
                                case 7:
                                    //text = "VII";
                                    break;
                                case 8:
                                    //text = "VIII";
                                    width = 0.15;
                                    break;
                                case 9:
                                    text = "IX ";
                                    break;
                                case 10:
                                    //text = " X ";
                                    break;
                                case 11:
                                    //text = "XI ";
                                    break;
                                case 12:
                                    text = "XII";
                                    break;
                                default:
                                    break;
                            }
                            this.ctx.fillText(text, 0, 0, this.radius * width); this.ctx.rotate(-ang); this.ctx.rotate(ang); this.ctx.translate(0, this.radius * 0.85); this.ctx.rotate(-ang)
                        }
                            break; case "nothing": break
                    }
                }
                drawTime() {
                    var now = new Date(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); hour = hour % 12; hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60)); var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90; this.ctx.save(); if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -4; this.ctx.shadowOffsetY = 3 }
                    if (this.handsCentreType == "circle" || this.handsCentreType == "circle") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI); this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour); this.ctx.fill() }
                    var extension = 0; if (this.handsLengthType == "extended" || this.handsLengthType == "extended") { extension = this.radius * 0.1 }
                    var lengthratio = 1; if (this.handsLengthType == "short") { lengthratio = 0.7 }
                    if (this.hourHandType != "cutout") { this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension) }
                    minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)); this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension); second = (second * Math.PI / 30); switch (this.secondHandType) { case 'nothing': break; case 'handscolour': this.drawHand(this.ctx, second, this.radius * 0.8, this.radius * 0.01, 0, '#DDDDDD', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#DDDDDD'; this.ctx.fill(); break; case 'red': this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#C71013'; this.ctx.fill(); break; default: break }
                }
                drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                    if (colour == null) { colour = this.handsColour }
                    if (transparentratio > 0) { this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius); this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, colour); this.strokestyle.addColorStop(1, colour); this.ctx.strokeStyle = this.strokestyle; this.ctx.lineCap = "butt" } else {
                        this.ctx.strokeStyle = colour; if (this.handsEndType == 'rounded') { this.ctx.lineCap = "round" }
                        switch (this.handsWidthType) { case "thin": width = width * 0.5; break; case "medium": break; case "thick": width = width * 2; break; default: break }
                    }
                    this.ctx.beginPath(); this.ctx.lineWidth = width; this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, -length); this.ctx.stroke(); this.ctx.rotate(-pos); if (neglength > 0) { this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, neglength); this.ctx.stroke(); this.ctx.rotate(-pos) }
                }
            }
            new renderclocksample6()
        </script>
        <script>
            class renderclocksample7 {
                constructor() { this.canvas = document.getElementById("canvas7"); this.backgroundColour = 'rgba(0,0,0,0)'; this.clockColour = '#FDFFFC'; this.handsColour = '#222222'; this.numbersType = 'roman'; this.secondHandType = 'none'; this.handsEndType = 'rounded'; this.handsWidthType = 'tapered'; this.handsCentreType = 'none'; this.handsLengthType = 'standard'; this.backgroundType = 'therefresh'; this.borderType = 'nothing'; this.dimensionType = '3d'; this.hourHandType = 'standard'; this.fps = 60; this.renderframe(); setInterval(this.renderframe.bind(this), 1000) }
                drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour; this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.ctx.restore(); this.drawFace(); this.drawNumbers() }
                renderframe() {
                    this.body = document.querySelector("body");
                    var oldss = this.ss;
                    this.ss = "260";
                    if (this.ss != oldss) { this.canvas.width = this.ss; this.canvas.height = this.ss; this.ctx = this.canvas.getContext("2d"); this.radius = this.canvas.height / 2; this.ctx.translate(this.radius, this.radius); this.canvasc = document.querySelector(".clockdiv"); this.canvasc.style.width = this.ss; this.canvasc.style.height = this.ss }
                    this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(); this.drawTime()
                }
                formatNumber(n) { return n.toString().padStart(2, "0") }
                drawFace() {
                    var grad; if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI); this.ctx.fillStyle = this.clockColour; this.ctx.fill() }
                    if (this.borderType != "nothing") {
                        if (this.borderType == "gradient") { grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1); grad.addColorStop(0, this.clockColour); grad.addColorStop(0.5, this.handsColour); grad.addColorStop(1, this.clockColour); this.ctx.strokeStyle = grad } else { this.ctx.strokeStyle = this.handsColour }
                        this.ctx.lineWidth = this.radius * 0.03; this.ctx.stroke()
                    }
                }
                drawNumbers() {
                    var ang; var num; this.ctx.font = this.radius * 0.15 + "px arial"; this.ctx.textBaseline = "middle"; this.ctx.textAlign = "center"; this.ctx.fillStyle = "#222222"; switch (this.numbersType) {
                        case "roman": this.ctx.font = this.radius * 0.25 + "px times new roman"; for (num = 1; num < 13; num++) {
                            ang = num * Math.PI / 6; this.ctx.rotate(ang); this.ctx.translate(0, -this.radius * 0.85); var text = ""; var width = 0.11; switch (num) {
                                case 1:
                                    //text = " I ";
                                    break;
                                case 2:
                                    //text = "II ";
                                    break;
                                case 3:
                                    text = "III";
                                    break;
                                case 4:
                                    //text = "IV";
                                    break;
                                case 5:
                                    //text = " V ";
                                    break;
                                case 6:
                                    text = "VI";
                                    break;
                                case 7:
                                    //text = "VII";
                                    break;
                                case 8:
                                    //text = "VIII";
                                    width = 0.15;
                                    break;
                                case 9:
                                    text = "IX ";
                                    break;
                                case 10:
                                    //text = " X ";
                                    break;
                                case 11:
                                    //text = "XI ";
                                    break;
                                case 12:
                                    text = "XII";
                                    break;
                                default:
                                    break;
                            }
                            this.ctx.fillText(text, 0, 0, this.radius * width); this.ctx.rotate(-ang); this.ctx.rotate(ang); this.ctx.translate(0, this.radius * 0.85); this.ctx.rotate(-ang)
                        }
                            break; case "nothing": break
                    }
                }
                drawTime() {
                    var now = new Date(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); hour = hour % 12; hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60)); var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90; this.ctx.save(); if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -4; this.ctx.shadowOffsetY = 3 }
                    if (this.handsCentreType == "circle" || this.handsCentreType == "circle") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI); this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour); this.ctx.fill() }
                    var extension = 0; if (this.handsLengthType == "extended" || this.handsLengthType == "extended") { extension = this.radius * 0.1 }
                    var lengthratio = 1; if (this.handsLengthType == "short") { lengthratio = 0.7 }
                    if (this.hourHandType != "cutout") { this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension) }
                    minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)); this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension); second = (second * Math.PI / 30); switch (this.secondHandType) { case 'nothing': break; case 'handscolour': this.drawHand(this.ctx, second, this.radius * 0.8, this.radius * 0.01, 0, '#DDDDDD', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#DDDDDD'; this.ctx.fill(); break; case 'red': this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#C71013'; this.ctx.fill(); break; default: break }
                }
                drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                    if (colour == null) { colour = this.handsColour }
                    if (transparentratio > 0) { this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius); this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, colour); this.strokestyle.addColorStop(1, colour); this.ctx.strokeStyle = this.strokestyle; this.ctx.lineCap = "butt" } else {
                        this.ctx.strokeStyle = colour; if (this.handsEndType == 'rounded') { this.ctx.lineCap = "round" }
                        switch (this.handsWidthType) { case "thin": width = width * 0.5; break; case "medium": break; case "thick": width = width * 2; break; default: break }
                    }
                    this.ctx.beginPath(); this.ctx.lineWidth = width; this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, -length); this.ctx.stroke(); this.ctx.rotate(-pos); if (neglength > 0) { this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, neglength); this.ctx.stroke(); this.ctx.rotate(-pos) }
                }
            }
            new renderclocksample7()
        </script>
</body>
</html>
<html>
<body style="margin:0;">

    <div class="clockdiv" style="width:80%; margin:auto;">

        <canvas id="canvas" width="256" height="256" style="top:0;left:0;width:100%;height:100%; border-radius:50%;"></canvas>

        <canvas style="padding: 0; position:relative; top:-100%; left:0;" id="canvas6"></canvas>

    </div>
    <script>
        class renderclocksample6 {
            constructor() { this.canvas = document.getElementById("canvas6"); this.backgroundColour = 'rgba(0,0,0,0)'; this.clockColour = '#FDFFFC'; this.handsColour = '#DDDDDD'; this.numbersType = 'none'; this.secondHandType = 'red'; this.handsEndType = 'rounded'; this.handsWidthType = 'tapered'; this.handsCentreType = 'circle'; this.handsLengthType = 'extended'; this.backgroundType = 'therefresh'; this.borderType = 'nothing'; this.dimensionType = '3d'; this.hourHandType = 'standard'; this.fps = 60; this.renderframe(); setInterval(this.renderframe.bind(this), 1000) }
            drawStaticBackground() { this.ctx.fillStyle = this.backgroundColour; this.ctx.fillRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.ctx.restore(); this.drawFace(); this.drawNumbers() }
            renderframe() {
                this.body = document.querySelector("body"); var oldss = this.ss; this.ss = (this.body.clientWidth < this.body.clientHeight ? this.body.clientWidth : this.body.clientHeight) * 0.8; if (this.ss != oldss) { this.canvas.width = this.ss; this.canvas.height = this.ss; this.ctx = this.canvas.getContext("2d"); this.radius = this.canvas.height / 2; this.ctx.translate(this.radius, this.radius); this.canvasc = document.querySelector(".clockdiv"); this.canvasc.style.width = this.ss; this.canvasc.style.height = this.ss }
                this.ctx.clearRect(-this.ss, -this.ss, this.ss * 2, this.ss * 2); this.drawStaticBackground(); this.drawTime()
            }
            formatNumber(n) { return n.toString().padStart(2, "0") }
            drawFace() {
                var grad; if (this.backgroundType != "fractal" && this.backgroundType != "therefresh") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI); this.ctx.fillStyle = this.clockColour; this.ctx.fill() }
                if (this.borderType != "nothing") {
                    if (this.borderType == "gradient") { grad = this.ctx.createRadialGradient(0, 0, this.radius * 0.9, 0, 0, this.radius * 1); grad.addColorStop(0, this.clockColour); grad.addColorStop(0.5, this.handsColour); grad.addColorStop(1, this.clockColour); this.ctx.strokeStyle = grad } else { this.ctx.strokeStyle = this.handsColour }
                    this.ctx.lineWidth = this.radius * 0.03; this.ctx.stroke()
                }
            }
            drawNumbers() {
                if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -2; this.ctx.shadowOffsetY = 1 }
                var ang; var num; this.ctx.font = this.radius * 0.15 + "px arial"; this.ctx.textBaseline = "middle"; this.ctx.textAlign = "center"; this.ctx.fillStyle = "#CCCCCC"; switch (this.numbersType) {
                    case "roman": this.ctx.font = this.radius * 0.25 + "px times new roman"; for (num = 1; num < 13; num++) {
                        ang = num * Math.PI / 6; this.ctx.rotate(ang); this.ctx.translate(0, -this.radius * 0.85); var text = ""; var width = 0.11; switch (num) {
                            case 1:
                                text = " I ";
                                break;
                            case 2:
                                text = "II ";
                                break;
                            case 3:
                                text = "III";
                                break;
                            case 4:
                                text = "IV";
                                break;
                            case 5:
                                text = " V ";
                                break;
                            case 6:
                                text = "VI";
                                break;
                            case 7:
                                text = "VII";
                                break;
                            case 8:
                                text = "VIII";
                                width = 0.15;
                                break;
                            case 9:
                                text = "IX ";
                                break;
                            case 10:
                                text = " X ";
                                break;
                            case 11:
                                text = "XI ";
                                break;
                            case 12:
                                text = "XII";
                                break;
                            default:
                                break;
                        }
                        this.ctx.fillText(text, 0, 0, this.radius * width); this.ctx.rotate(-ang); this.ctx.rotate(ang); this.ctx.translate(0, this.radius * 0.85); this.ctx.rotate(-ang)
                    }
                        break; case "nothing": break
                }
            }
            drawTime() {
                var now = new Date(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); hour = hour % 12; hour = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60)); var ang = now.getHours() % 12 * 30 + (now.getMinutes() * 0.5) - 90; this.ctx.save(); if (this.dimensionType == "3d") { this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#222222'; this.ctx.shadowOffsetX = -4; this.ctx.shadowOffsetY = 3 }
                if (this.handsCentreType == "circle" || this.handsCentreType == "circle") { this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.05, 0, 2 * Math.PI); this.ctx.fillStyle = (this.hourHandType == "cutout" ? this.clockColour : this.handsColour); this.ctx.fill() }
                var extension = 0; if (this.handsLengthType == "extended" || this.handsLengthType == "extended") { extension = this.radius * 0.1 }
                var lengthratio = 1; if (this.handsLengthType == "short") { lengthratio = 0.7 }
                if (this.hourHandType != "cutout") { this.drawHand(this.ctx, hour, this.radius * 0.5 * lengthratio, this.radius * 0.03, 0, null, extension) }
                minute = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)); this.drawHand(this.ctx, minute, this.radius * 0.7 * lengthratio, this.radius * 0.02, 0, (this.hourHandType == "cutout" ? this.clockColour : this.handsColour), extension); second = (second * Math.PI / 30); switch (this.secondHandType) { case 'nothing': break; case 'handscolour': this.drawHand(this.ctx, second, this.radius * 0.8, this.radius * 0.01, 0, '#DDDDDD', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#DDDDDD'; this.ctx.fill(); break; case 'red': this.drawHand(this.ctx, second, this.radius * 0.9, this.radius * 0.01, 0, '#C71013', this.radius * 0.2); this.ctx.beginPath(); this.ctx.arc(0, 0, this.radius * 0.015, 0, 2 * Math.PI); this.ctx.fillStyle = '#C71013'; this.ctx.fill(); break; default: break }
            }
            drawHand(ctx, pos, length, width, transparentratio, colour, neglength) {
                if (colour == null) { colour = this.handsColour }
                if (transparentratio > 0) { this.strokestyle = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius); this.strokestyle.addColorStop(0, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, 'rgba(255, 255, 255, 0)'); this.strokestyle.addColorStop(transparentratio, colour); this.strokestyle.addColorStop(1, colour); this.ctx.strokeStyle = this.strokestyle; this.ctx.lineCap = "butt" } else {
                    this.ctx.strokeStyle = colour; if (this.handsEndType == 'rounded') { this.ctx.lineCap = "round" }
                    switch (this.handsWidthType) { case "thin": width = width * 0.5; break; case "medium": break; case "thick": width = width * 2; break; default: break }
                }
                this.ctx.beginPath(); this.ctx.lineWidth = width; this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, -length); this.ctx.stroke(); this.ctx.rotate(-pos); if (neglength > 0) { this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.rotate(pos); this.ctx.lineTo(0, neglength); this.ctx.stroke(); this.ctx.rotate(-pos) }
            }
        }
        new renderclocksample6()
    </script>

    <script>
        "use strict";

        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }

            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgramFromSources(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        function main() {
            const canvas = document.querySelector("#canvas");
            const gl = canvas.getContext("webgl");
            if (!gl) {
                return;
            }

            const vs = `
                attribute vec4 a_position;

                void main() {
                  gl_Position = a_position;
                }
              `;

            const fs = `
                precision highp float;

                uniform vec2 iResolution;
                uniform vec2 iMouse;
                uniform float iTime;

                #define t iTime
                #define r iResolution.xy

float Hash21(vec2 p) {
    p = fract(p*vec2(234.34, 435.345));
    p += dot(p, p+34.23);
    return fract(p.x*p.y);
}

vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{

    return a + b*cos( 6.28318*(c*t+d) );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;

    vec2 origuv = fragCoord.xy/iResolution.xy; //original uvs for actual pixels

    vec3 col = vec3(0);

    //uv.xy += sin(iTime*0.015)*cos(iTime*0.017); //pan
    //uv.xy *= abs((sin(iTime*0.03))) + .5; //zoom


    uv *= 20.;
    vec2 gv = fract(uv)-.5;
    vec2 id = floor(uv);
    //col.rg = gv;
    float n = Hash21(id); //random no 0 to 1

    float width = .5;
    if (n<.5) gv.x *= -1.; //flip half random tiles

    //generate truchet pattern
    float d = abs(abs(gv.x + gv.y) - .5);

    vec2 cUv = gv-.5*sign(gv.x + gv.y+.001);

    d = length(cUv);

    float mask = smoothstep(.01, -.01, abs(d-.5)-width);

    float angle = atan(cUv.x, cUv.y);

    float checker = mod(id.x+id.y, 2.)*2. - 1.; //identify checkerboard alternate tiles

    float flow = sin(checker*angle*10.+iTime*2.); //flow multiplied by checker to make consistent flow

    float x = fract(angle/1.57); //x dim is length of line
    float y = (d-(.5-width))/(width*2.); //y dim is shading on width of line
    y = min(1.-abs(y-.5)*2., 0.9);


    //col += vec3(255./255.,208./255.,147./255.);

    //col += x*mask;
      col += y*mask;
    col += flow*mask*0.07;



    vec2 p = uv.xy /1.; //multiplier to get the pallete correct

    p.x = (p.x); //offset to go back to 0 to 1 coords?

    float radius = sqrt(p.x*p.x + p.y*p.y);
    // animate
    //p.x += .5*radius* (0.5* (1.0 + sin(iTime*5.)));
    radius *= (0.1* (1.0 + sin(iTime*0.3)));

    //vectors taken from http://dev.thi.ng/gradients/

    //col *= pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20));
    col *= pal(radius, vec3(0.948, 0.778, 0.638),vec3(0.137, -0.045, 0.230),vec3(0.500, 0.000, 0.500),vec3(0.000, 0.000, 0.500) );
   //[0.000 0.500 0.500] [0.000 0.500 0.500] [0.000 0.500 0.333] [0.000 0.500 0.667]
   //[[0.938 0.328 0.718] [0.659 0.438 0.328] [0.388 0.388 0.296] [2.538 2.478 0.168]]
   //col += vec3(255./255.,208./255.,147./255.);
   //[[0.948 0.778 0.638] [0.358 0.000 0.500] [0.500 0.000 0.500] [0.000 0.000 0.500]]

   //col.r *= 1.-abs(uv.x/5.)*(sin(iTime*0.05)*cos(iTime*0.07)); //red
    //col.g *= 1. -abs(uv.y/5.)*(sin(iTime*0.05)*cos(iTime*0.07)); //green
    //col.z = origuv.x;


    // Output to screen
    fragColor = vec4(col,1.0) *1.;
}

                void main() {
                  mainImage(gl_FragColor, gl_FragCoord.xy);
                }
              `;

            var vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
            var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

            const program = createProgramFromSources(gl, vertexShader, fragmentShader);

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

            const resolutionLocation = gl.getUniformLocation(program, "iResolution");
            const mouseLocation = gl.getUniformLocation(program, "iMouse");
            const timeLocation = gl.getUniformLocation(program, "iTime");

            const positionBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                -1, 1,
                1, -1,
                1, 1,
            ]), gl.STATIC_DRAW);

            let requestId;
            function requestFrame() {
                if (!requestId) {
                    requestId = requestAnimationFrame(render);
                }
            }
            function cancelFrame() {
                if (requestId) {
                    cancelAnimationFrame(requestId);
                    requestId = undefined;
                }
            }

            setInterval(requestFrame, 10);

            let then = 0;
            let time = 0;
            function render(now) {
                requestId = undefined;
                now *= 0.001;
                const elapsedTime = Math.min(now - then, 0.1);
                time += elapsedTime;
                then = now;

                //webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.useProgram(program);

                gl.enableVertexAttribArray(positionAttributeLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                gl.vertexAttribPointer(
                    positionAttributeLocation,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0,
                );

                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(timeLocation, time);

                gl.drawArrays(
                    gl.TRIANGLES,
                    0,
                    6,
                );

                requestFrame();
            }

            requestFrame();
            requestAnimationFrame(cancelFrame);
        }

        main();

    </script>
</body>
</html>